<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-lang-key="html-title">–§–∏–∑–∏–∫–∞: –ö–∞—Ä—Ç–æ—á–∫–∏ –∏ –ó–∞–¥–∞—á–∏</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* --- –°—Ç–∏–ª–∏ (–¥–æ–ø–æ–ª–Ω–µ–Ω—ã) --- */
        :root {
            --primary-color: #007bff; --secondary-color: #6c757d;
            --background-light: #f8f9fa; --text-dark: #212529; --text-light: #f8f9fa;
            --success-color: #28a745; --error-color: #dc3545;
            --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); --transition-speed: 0.3s;
            --card-bg-front: #ffffff; --card-bg-back: #e9ecef;
            --card-text-front: var(--text-dark); --card-text-back: var(--text-dark);
            --timer-color: var(--secondary-color);
        }
        .dark-mode {
            --primary-color: #4dabf7; --secondary-color: #adb5bd;
            --background-light: #1a1a1a; --text-dark: #e9ecef; --text-light: #343a40;
            --card-shadow: 0 4px 12px rgba(255, 255, 255, 0.08);
            --card-bg-front: #2b2b2b; --card-bg-back: #3a3a3a;
            --card-text-front: var(--text-dark); --card-text-back: var(--text-dark);
            --timer-color: var(--secondary-color);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
        body { background-color: var(--background-light); color: var(--text-dark); transition: background-color var(--transition-speed), color var(--transition-speed); min-height: 100vh; display: flex; flex-direction: column; font-size: 16px; }
        header { background: linear-gradient(135deg, var(--primary-color), #0056b3); color: white; padding: 1.5rem; text-align: center; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        header h1 { font-size: 2rem; margin-bottom: 0.3rem;}
        header p { font-size: 1rem; opacity: 0.9; }
        .container { width: 90%; max-width: 1200px; margin: 2rem auto; padding: 0 1rem; flex: 1; }

        /* –ü–∞–Ω–µ–ª—å –Ω–∞—Å—Ç—Ä–æ–µ–∫ */
        .settings-bar { display: flex; justify-content: space-between; align-items: center; padding: 0.8rem 1rem; gap: 1rem; flex-wrap: wrap; border-bottom: 1px solid #dee2e6; margin-bottom: 1rem; background-color: var(--card-bg-front); border-radius: 8px; box-shadow: var(--card-shadow); } /* Reduced margin-bottom */
        .dark-mode .settings-bar { border-bottom-color: #444; }
        .settings-left, .settings-right { display: flex; gap: 0.8rem; align-items: center; }
        .theme-toggle, .language-toggle { background: none; border: none; cursor: pointer; font-size: 1.6rem; color: var(--secondary-color); padding: 0.3rem; transition: color 0.2s; }
        .theme-toggle:hover, .language-toggle:hover { color: var(--primary-color); }
        .language-dropdown { position: relative; display: inline-block; }
        .language-menu { display: none; position: absolute; right: 0; top: 110%; margin-top: 5px; background-color: var(--card-bg-front); color: var(--card-text-front); min-width: 120px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); border-radius: 8px; z-index: 100; border: 1px solid #eee; }
        .dark-mode .language-menu { border-color: #444; }
        .language-menu.show { display: block; }
        .language-option { padding: 0.8rem 1rem; cursor: pointer; transition: background-color 0.2s; font-size: 0.95rem; }
        .language-option:hover { background-color: rgba(0, 123, 255, 0.1); }
        .dark-mode .language-option:hover { background-color: rgba(77, 171, 247, 0.15); }

        /* –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –∫–æ–ª–æ–¥—ã */
        #currentDeckDisplay { text-align: center; margin-bottom: 1.5rem; font-size: 0.95rem; color: var(--secondary-color); }
        #currentDeckDisplay span { font-weight: 600; color: var(--text-dark); }
        .dark-mode #currentDeckDisplay span { color: var(--text-dark); }


        /* –ö–Ω–æ–ø–∫–∏ –æ–±—â–∏–µ */
        button, .button-style { background-color: var(--primary-color); color: white; border: none; padding: 0.7rem 1.3rem; border-radius: 6px; cursor: pointer; font-size: 0.95rem; transition: background-color 0.2s, transform 0.1s, opacity 0.2s, box-shadow 0.2s; display: inline-flex; align-items: center; gap: 0.5rem; text-align: center; justify-content: center; line-height: 1.4; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        button:hover:not(:disabled), .button-style:hover:not(:disabled) { background-color: #0056b3; box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .dark-mode button:hover:not(:disabled), .dark-mode .button-style:hover:not(:disabled) { background-color: #69b7f9; }
        button:active:not(:disabled), .button-style:active:not(:disabled) { transform: scale(0.98); box-shadow: none; }
        button:disabled, .button-style:disabled { opacity: 0.6; cursor: not-allowed; background-color: #adb5bd !important; color: #fff !important; border-color: transparent !important; box-shadow: none; }
        .button-secondary { background-color: var(--secondary-color); }
        .button-secondary:hover:not(:disabled) { background-color: #5a6268; }
        .button-outline { background-color: transparent; color: var(--primary-color); border: 1px solid var(--primary-color); box-shadow: none; }
        .button-outline:hover:not(:disabled) { background-color: rgba(0, 123, 255, 0.1); }
        .dark-mode .button-outline { color: var(--primary-color); border-color: var(--primary-color); }
        .dark-mode .button-outline:hover:not(:disabled) { background-color: rgba(77, 171, 247, 0.15); }
        .button-outline:disabled { border-color: #ccc !important; color: #aaa !important; background-color: transparent !important; opacity: 0.5; }

        /* –†–µ–∂–∏–º—ã –æ–±—É—á–µ–Ω–∏—è */
        .study-modes { display: flex; justify-content: center; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; } /* Reduced margin */
        .mode-card { background-color: var(--card-bg-front); color: var(--card-text-front); border-radius: 10px; padding: 1.5rem; width: 200px; text-align: center; cursor: pointer; box-shadow: var(--card-shadow); transition: transform 0.3s, border-color 0.3s, opacity 0.3s; border: 2px solid transparent; }
        .mode-card:hover:not(.disabled) { transform: translateY(-5px); border-color: var(--secondary-color); }
        .mode-card.active { border-color: var(--primary-color); transform: translateY(-3px); box-shadow: 0 6px 15px rgba(0, 123, 255, 0.2); }
        .mode-card.disabled { opacity: 0.4; cursor: not-allowed; background-color: #eee; border-color: transparent; transform: none; box-shadow: none; pointer-events: none; }
        .dark-mode .mode-card.disabled { background-color: #333; }
        .mode-icon { font-size: 2.2rem; margin-bottom: 1rem; color: var(--primary-color); }
        .mode-card h3 { font-size: 1.1rem; margin-bottom: 0.4rem; }
        .mode-card p { font-size: 0.9rem; color: #6c757d; }
        .dark-mode .mode-card p { color: #adb5bd; }

        /* –ü—Ä–æ–≥—Ä–µ—Å—Å –∏ –¢–∞–π–º–µ—Ä */
        .progress-timer-container { display: flex; justify-content: space-between; align-items: center; max-width: 700px; margin: 0 auto 2rem; gap: 1rem; }
        .progress-container { flex-grow: 1; background-color: #e9ecef; border-radius: 10px; overflow: hidden; height: 12px; }
        .dark-mode .progress-container { background-color: #3a3a3a; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, var(--primary-color), #0056b3); transition: width 0.3s ease; width: 0%; border-radius: 10px; }
        #timerDisplay { font-size: 1rem; color: var(--timer-color); font-weight: 500; min-width: 50px; text-align: right; visibility: hidden; /* Hidden by default */ }
        #timerDisplay.visible { visibility: visible; }


        /* –û–±–ª–∞—Å—Ç—å –∫–∞—Ä—Ç–æ—á–∫–∏ */
        .flashcard-area { perspective: 1000px; min-height: 380px; margin-bottom: 2rem; }
        .flashcard-container { position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
        .flashcard { width: 700px; max-width: 100%; height: 380px; position: relative; cursor: pointer; transform-style: preserve-3d; transition: transform 0.6s; box-shadow: var(--card-shadow); border-radius: 12px; }
        .flashcard.flipped { transform: rotateY(180deg); }
        .flashcard-front, .flashcard-back { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 2rem 2.5rem; border-radius: 12px; text-align: center; overflow-y: auto; border: 1px solid #eee;}
        .flashcard-front { background-color: var(--card-bg-front); color: var(--card-text-front); }
        .flashcard-back { transform: rotateY(180deg); background-color: var(--card-bg-back); color: var(--card-text-back); }
        .dark-mode .flashcard-front, .dark-mode .flashcard-back { border-color: #333; }
        .flashcard-term-topic { font-size: 1.8rem; margin-bottom: 0.8rem; font-weight: 600; color: var(--primary-color); }
        .flashcard-term-prompt { font-size: 1rem; color: #6c757d; margin-bottom: 1rem; }
        .dark-mode .flashcard-term-prompt { color: #adb5bd; }
        .flashcard-back-section { margin-bottom: 0.8rem; width: 100%; text-align: left; padding-left: 1rem;}
        .flashcard-back-section strong { display: block; margin-bottom: 0.3rem; font-size: 0.95rem; color: var(--primary-color); font-weight: 600;}
        .flashcard-back-content { font-size: 1rem; line-height: 1.6; }
        .flashcard-problem-text { font-size: 1.15rem; line-height: 1.65; text-align: left; width: 100%; margin-top: 0.5rem;}
        .flashcard-problem-answer { font-size: 1.6rem; font-weight: bold; color: var(--success-color); margin-top: 1.5rem; }
        @keyframes cardEntrance { from { opacity: 0; transform: translateY(20px) scale(0.98); } to { opacity: 1; transform: translateY(0) scale(1); } }
        .card-animation { animation: cardEntrance 0.4s ease-out; }

        /* –†–µ–∂–∏–º –¢–µ—Å—Ç–∞ */
        .quiz-options { display: none; flex-wrap: wrap; justify-content: center; gap: 1rem; margin-top: 1.5rem; max-width: 700px; margin-left: auto; margin-right: auto;}
        .quiz-option { flex-basis: calc(50% - 1rem); text-align: center; }
        .quiz-option.correct { background-color: var(--success-color); color: white; border-color: var(--success-color); }
        .quiz-option.incorrect { background-color: var(--error-color); color: white; border-color: var(--error-color); }

        /* –†–µ–∂–∏–º –ó–∞–¥–∞—á–∏ */
        .problem-solver { display: none; width: 100%; max-width: 700px; margin: 1.5rem auto; text-align: center; }
        .problem-solver label { display: block; margin-bottom: 0.8rem; font-size: 1rem; font-weight: 500; }
        .problem-solver input[type="number"], .problem-solver input[type="text"] { width: 60%; padding: 0.8rem 1rem; border: 1px solid #ccc; border-radius: 6px; font-size: 1.1rem; text-align: center; background-color: var(--card-bg-front); color: var(--card-text-front); margin: 0 auto 1rem auto; display: block; }
        .dark-mode .problem-solver input { border-color: #555; background-color: #2b2b2b; }
        .problem-solver input:focus { border-color: var(--primary-color); outline: none; box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.15); }
        .submit-answer { width: auto; min-width: 150px; }

        /* –û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å */
        .answer-feedback { display: none; margin-top: 1.5rem; padding: 1rem 1.5rem; border-radius: 8px; text-align: center; font-weight: 500; width: 100%; max-width: 700px; margin-left: auto; margin-right: auto; font-size: 1.05rem; }
        .answer-feedback.correct { background-color: rgba(40, 167, 69, 0.1); color: var(--success-color); border: 1px solid rgba(40, 167, 69, 0.3); }
        .answer-feedback.incorrect { background-color: rgba(220, 53, 69, 0.1); color: var(--error-color); border: 1px solid rgba(220, 53, 69, 0.3); }
        .answer-feedback .correct-answer-text { font-weight: bold; margin-left: 5px;}

        /* –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
        .controls { display: flex; justify-content: center; gap: 1rem; margin: 2rem 0; flex-wrap: wrap; }

        /* –°–µ–∫—Ü–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ */
        .stats-section { background-color: var(--card-bg-front); color: var(--card-text-front); padding: 1.5rem 2rem; border-radius: 12px; margin-top: 2.5rem; box-shadow: var(--card-shadow); border: 1px solid #eee;}
        .dark-mode .stats-section { border-color: #333; }
        .stats-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid #eee; }
        .dark-mode .stats-header { border-bottom-color: #444; }
        .stats-header h2 { font-size: 1.4rem; margin: 0; }
        #resetStatsBtn { font-size: 0.85rem; padding: 0.5rem 1rem; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; }
        .stat-card { background-color: var(--background-light); color: var(--text-dark); padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid #eee;}
        .dark-mode .stat-card { background-color: #252525; border-color: #444; }
        .stat-value { font-size: 1.8rem; font-weight: 600; color: var(--primary-color); margin-bottom: 0.5rem; }
        .stat-label { color: var(--secondary-color); font-size: 0.85rem; text-transform: uppercase; }
        .dark-mode .stat-label { color: #adb5bd; }

        /* –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ */
        .modal { display: none; position: fixed; z-index: 1050; left: 0; top: 0; width: 100%; height: 100%; overflow-y: auto; background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(3px); animation: fadeIn 0.3s ease; align-items: center; justify-content: center; padding: 1rem; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .modal-content { background-color: var(--card-bg-front); color: var(--card-text-front); padding: 2rem; border-radius: 12px; width: 90%; max-width: 700px; max-height: 90vh; overflow-y: auto; position: relative; animation: slideIn 0.3s ease-out; margin: auto; }
        @keyframes slideIn { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid #eee; }
        .dark-mode .modal-header { border-bottom-color: #444;}
        .modal-header h2 { font-size: 1.5rem; margin: 0; }
        .close-modal { background: none; border: none; font-size: 2rem; cursor: pointer; color: var(--secondary-color); padding: 0; line-height: 1; opacity: 0.7; position: absolute; top: 1rem; right: 1.5rem;}
        .close-modal:hover { opacity: 1; color: var(--error-color); }

        /* –°–ø–∏—Å–æ–∫ –∫–æ–ª–æ–¥ */
        .deck-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1rem; list-style: none; padding: 0;}
        .deck-item { background-color: var(--background-light); color: var(--text-dark); padding: 1.2rem; border-radius: 8px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; position: relative; border: 1px solid #eee; }
        .dark-mode .deck-item { background-color: #252525; border-color: #444; }
        .deck-item:hover { transform: translateY(-3px); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1); border-color: var(--primary-color); }
        .deck-title { font-weight: 600; font-size: 1.15rem; margin-bottom: 0.5rem; color: var(--primary-color); }
        .deck-info { color: #555; font-size: 0.9rem; margin-bottom: 0.3rem; }
        .dark-mode .deck-info { color: #bbb; }
        .delete-deck-btn { position: absolute; top: 8px; right: 8px; background: rgba(220, 53, 69, 0.1); color: var(--error-color); border: 1px solid rgba(220, 53, 69, 0.3); border-radius: 50%; width: 28px; height: 28px; font-size: 1rem; line-height: 28px; text-align: center; cursor: pointer; opacity: 0.8; transition: opacity 0.2s, background-color 0.2s; padding: 0; }
        .deck-item:hover .delete-deck-btn { opacity: 1; background: rgba(220, 53, 69, 0.2); }

        /* –§–æ—Ä–º–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–ª–æ–¥—ã */
        .create-deck-form label { display: block; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: 600; font-size: 0.95rem; }
        .create-deck-form select { width: 100%; padding: 0.8rem; border: 1px solid #ccc; border-radius: 5px; font-size: 1rem; background-color: var(--background-light); color: var(--text-dark); margin-bottom: 1rem; }
        .dark-mode .create-deck-form select { background-color: #252525; border-color: #555; }
        .create-deck-form input[type="text"], .create-deck-form textarea { width: 100%; padding: 0.8rem; border: 1px solid #ccc; border-radius: 5px; font-size: 1rem; background-color: var(--background-light); color: var(--text-dark); margin-bottom: 1rem; transition: border-color 0.2s, box-shadow 0.2s; }
        .dark-mode .create-deck-form input[type="text"], .dark-mode .create-deck-form textarea { background-color: #252525; border-color: #555;}
        .create-deck-form input[type="text"]:focus, .create-deck-form textarea:focus, .create-deck-form select:focus { border-color: var(--primary-color); outline: none; box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.15); }
        .create-deck-form textarea { min-height: 80px; resize: vertical; }
        .create-deck-form button[type="submit"] { margin-top: 1.5rem; width: 100%; font-size: 1.1rem; padding: 0.9rem 1.5rem; }
        .add-card-section { border-top: 1px solid #eee; margin-top: 2rem; padding-top: 1.5rem; }
        .dark-mode .add-card-section { border-top-color: #444;}
        .add-card-section h3 { margin-bottom: 1rem; font-size: 1.3rem; }
        .term-inputs, .problem-inputs { border: 1px solid #eee; padding: 1.5rem; margin-bottom: 1.5rem; border-radius: 8px; background-color: rgba(0,0,0,0.02); position: relative; }
        .dark-mode .term-inputs, .dark-mode .problem-inputs { background-color: rgba(255,255,255,0.04); border-color: #444;}
        .term-inputs h4, .problem-inputs h4 { margin-bottom: 1rem; font-size: 1.1rem; color: var(--primary-color); }
        .delete-term-btn, .delete-problem-btn { position: absolute; top: 10px; right: 10px; background: transparent; color: var(--error-color); border: none; padding: 0.2rem 0.5rem; font-size: 1.4rem; cursor: pointer; line-height: 1; opacity: 0.6; transition: opacity 0.2s; }
        .delete-term-btn:hover, .delete-problem-btn:hover { opacity: 1; }
        #addAnotherTermBtn, #addAnotherProblemBtn { width: 100%; margin-top: 0.5rem; }


        /* –ó–Ω–∞—á–∫–∏ */
        .badge-earned { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); background-color: rgba(0,0,0,0.85); color: white; padding: 2rem 3rem; border-radius: 12px; text-align: center; z-index: 1100; display: none; animation: badgeEntrance 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes badgeEntrance { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
        .badge-icon { font-size: 3rem; color: gold; margin-bottom: 1rem; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        .badge-earned h3 { margin-bottom: 0.5rem; font-size: 1.4rem; }
        .badge-earned p { font-size: 1rem; opacity: 0.9; }

        /* –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –î–æ—Å—Ç–∏–∂–µ–Ω–∏–π */
        #achievementsList { list-style: none; padding: 0; max-height: 60vh; overflow-y: auto; }
        .achievement-item { background-color: var(--background-light); color: var(--text-dark); padding: 1rem 1.5rem; margin-bottom: 0.8rem; border-radius: 8px; border: 1px solid #eee; display: flex; align-items: center; gap: 1rem; }
        .dark-mode .achievement-item { background-color: #252525; border-color: #444; }
        .achievement-icon { font-size: 2rem; color: gold; }
        .achievement-details h4 { margin: 0 0 0.3rem 0; font-size: 1.1rem; color: var(--primary-color); }
        .achievement-details p { margin: 0; font-size: 0.9rem; color: var(--secondary-color); }
        .dark-mode .achievement-details p { color: #adb5bd; }
        #achievementsList li:empty { display: none; } /* Hide if empty */
        #achievementsList .no-achievements { text-align: center; padding: 2rem; color: var(--secondary-color); }


        /* –ü–æ–¥–≤–∞–ª */
        footer { background-color: #343a40; color: #adb5bd; text-align: center; padding: 1.5rem; margin-top: 3rem; font-size: 0.9rem; }
        .dark-mode footer { background-color: #111; }

        /* –ú–µ–¥–∏–∞-–∑–∞–ø—Ä–æ—Å—ã */
        @media (max-width: 768px) { .container { width: 95%; margin: 1rem auto; } .flashcard { height: auto; min-height: 320px; } .flashcard-front, .flashcard-back { padding: 1.5rem; } .flashcard-term-topic { font-size: 1.5rem; } .flashcard-content, .flashcard-problem-text, .flashcard-back-content { font-size: 1rem; } .controls { gap: 0.5rem; } button, .button-style { padding: 0.7rem 1.2rem; font-size: 0.9rem; } .settings-bar { justify-content: center; } .study-modes { gap: 0.5rem; } .mode-card { width: calc(33% - 0.5rem); padding: 1rem; } .stat-value { font-size: 1.5rem; } .modal-content { max-width: 95%; padding: 1.5rem; } .quiz-option { flex-basis: 100%; } .progress-timer-container { flex-direction: column; align-items: stretch; gap: 0.5rem;} #timerDisplay { text-align: center;} }
        @media (max-width: 480px) { .flashcard { min-height: 300px; } .settings-bar { flex-direction: column; gap: 0.8rem; } .settings-left, .settings-right { width: 100%; justify-content: space-around;} .mode-card { width: calc(50% - 0.5rem); } .stats-grid { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 0.5rem;} .stat-card { padding: 0.8rem; } .stat-value { font-size: 1.3rem; } header h1 {font-size: 1.6rem;} header p {font-size: 0.9rem;} .deck-list { grid-template-columns: 1fr; } }

    </style>
    <script>
        window.MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          },
          options: {
              skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'], // Ignore MathJax in these tags
              ignoreHtmlClass: 'tex2jax_ignore', // Ignore elements with this class
              processHtmlClass: 'tex2jax_process' // Process elements with this class
          }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
</head>
<body>
    <header>
        <h1 id="header-title" data-lang-key="header-title">–§–∏–∑–∏–∫–∞: –ö–∞—Ä—Ç–æ—á–∫–∏ –∏ –ó–∞–¥–∞—á–∏</h1>
        <p id="header-subtitle" data-lang-key="header-subtitle">–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –∏–∑—É—á–µ–Ω–∏–µ —Ñ–∏–∑–∏–∫–∏</p>
    </header>

    <div class="settings-bar">
        <div class="settings-left">
            <button id="chooseDeckBtn" class="button-outline" data-lang-key="choose-deck">–í—ã–±—Ä–∞—Ç—å –∫–æ–ª–æ–¥—É</button>
            <button id="createDeckBtn" class="button-outline" data-lang-key="create-deck">–°–æ–∑–¥–∞—Ç—å –∫–æ–ª–æ–¥—É</button>
            <button id="achievementsBtn" class="button-outline" data-lang-key="achievements">üèÜ –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è</button> </div>
        <div class="settings-right">
             <div class="language-dropdown">
                <button id="languageToggle" class="language-toggle" aria-label="Select Language" data-lang-key="select-language" title="Select Language">üåê</button>
                <div id="languageMenu" class="language-menu">
                    <div class="language-option" data-lang="en">English</div>
                    <div class="language-option" data-lang="ru">–†—É—Å—Å–∫–∏–π</div>
                    <div class="language-option" data-lang="es">Espa√±ol</div>
                </div>
            </div>
            <button id="themeToggle" class="theme-toggle" aria-label="Toggle theme" data-lang-key="toggle-theme" title="Toggle theme">üåô</button>
        </div>
    </div>

     <div id="currentDeckDisplay" class="container" data-lang-key="current-deck-label">–¢–µ–∫—É—â–∞—è –∫–æ–ª–æ–¥–∞: <span></span></div>


    <div class="container">
        <div class="study-modes">
            <div class="mode-card active" data-mode="flashcard" id="flashcardModeCard">
                <div class="mode-icon">üîÑ</div>
                <h3 data-lang-key="mode-flashcards">–¢–µ—Ä–º–∏–Ω—ã</h3>
                <p data-lang-key="mode-flashcards-desc">–ò–∑—É—á–µ–Ω–∏–µ –ø–æ–Ω—è—Ç–∏–π</p>
            </div>
            <div class="mode-card" data-mode="quiz" id="quizModeCard">
                <div class="mode-icon">üìù</div>
                <h3 data-lang-key="mode-quiz">–¢–µ—Å—Ç</h3>
                <p data-lang-key="mode-quiz-desc">–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–Ω–∞–Ω–∏–π</p>
            </div>
            <div class="mode-card" data-mode="problems" id="problemsModeCard">
                <div class="mode-icon">üßÆ</div>
                <h3 data-lang-key="mode-problems">–ó–∞–¥–∞—á–∏</h3>
                <p data-lang-key="mode-problems-desc">–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á</p>
            </div>
        </div>

         <div class="progress-timer-container">
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div id="timerDisplay">00:00</div> </div>


        <div class="flashcard-area">
            <div class="flashcard-container">
                <div class="flashcard" id="flashcard">
                    <div class="flashcard-front"></div>
                    <div class="flashcard-back"></div>
                </div>
            </div>
        </div>

        <div class="quiz-options" id="quizOptions"></div>
        <div class="problem-solver" id="problemSolverContainer">
            <label for="problemAnswerInput" data-lang-key="problem-input-label">–í–≤–µ–¥–∏—Ç–µ –æ—Ç–≤–µ—Ç (—á–∏—Å–ª–æ):</label>
            <input type="number" id="problemAnswerInput" placeholder="0" step="any">
            <button class="submit-answer button-style" id="submitProblemAnswer" data-lang-key="submit-answer">–û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç</button>
        </div>
        <div class="answer-feedback" id="answerFeedback"></div>

        <div class="controls">
            <button id="prevBtn" class="button-secondary" disabled>
                <span>‚ùÆ</span>&nbsp;<span data-lang-key="previous">–ù–∞–∑–∞–¥</span>
            </button>
            <button id="flipBtn" data-lang-key="flip-card">
                –ü–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—å
            </button>
            <button id="nextBtn">
                <span data-lang-key="next">–î–∞–ª–µ–µ</span>&nbsp;<span>‚ùØ</span>
            </button>
            <button id="shuffleBtn" class="button-outline" data-lang-key="shuffle">
                –ü–µ—Ä–µ–º–µ—à–∞—Ç—å
            </button>
        </div>

        <div class="stats-section">
            <div class="stats-header">
                <h2 data-lang-key="learning-progress">–ü—Ä–æ–≥—Ä–µ—Å—Å –æ–±—É—á–µ–Ω–∏—è</h2>
                <button id="resetStatsBtn" class="button-outline" data-lang-key="reset-stats" title="–°–±—Ä–æ—Å–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–µ—Å—Å–∏–∏">–°–±—Ä–æ—Å–∏—Ç—å</button>
            </div>
            <div class="stats-grid">
                <div class="stat-card"><div class="stat-value" id="cardsReviewed">0</div><div class="stat-label" data-lang-key="cards-reviewed">–ü—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–æ</div></div>
                <div class="stat-card"><div class="stat-value" id="correctAnswers">0</div><div class="stat-label" data-lang-key="correct-answers">–ü—Ä–∞–≤–∏–ª—å–Ω–æ</div></div>
                <div class="stat-card"><div class="stat-value" id="totalAttempts">0</div><div class="stat-label" data-lang-key="total-attempts">–ü–æ–ø—ã—Ç–æ–∫</div></div>
                <div class="stat-card"><div class="stat-value" id="accuracy">0%</div><div class="stat-label" data-lang-key="accuracy-rate">–¢–æ—á–Ω–æ—Å—Ç—å</div></div>
                <div class="stat-card"><div class="stat-value" id="streakCount">0</div><div class="stat-label" data-lang-key="current-streak">–°–µ—Ä–∏—è</div></div>
            </div>
        </div>
    </div>

    <div class="modal" id="deckModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 data-lang-key="choose-deck-modal">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–æ–¥—É</h2>
                <button class="close-modal" id="closeDeckModal" aria-label="–ó–∞–∫—Ä—ã—Ç—å" title="–ó–∞–∫—Ä—ã—Ç—å">&times;</button>
            </div>
            <ul class="deck-list" id="deckList"></ul>
        </div>
    </div>

     <div class="modal" id="createDeckModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="createDeckModalTitle" data-lang-key="create-new-deck-modal">–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∫–æ–ª–æ–¥—É</h2>
                <button class="close-modal" id="closeCreateDeckModal" aria-label="–ó–∞–∫—Ä—ã—Ç—å" title="–ó–∞–∫—Ä—ã—Ç—å">&times;</button>
            </div>
            <form id="createDeckForm" class="create-deck-form">
                <label for="deckTitleInput" data-lang-key="deck-title-label">–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ª–æ–¥—ã:</label>
                <input type="text" id="deckTitleInput" required>
                <label for="deckDescInput" data-lang-key="deck-desc-label">–û–ø–∏—Å–∞–Ω–∏–µ:</label>
                <input type="text" id="deckDescInput">
                <label for="deckTypeInput" data-lang-key="deck-type-label">–¢–∏–ø –∫–æ–ª–æ–¥—ã:</label>
                <select id="deckTypeInput" required>
                    <option value="terms" data-lang-key="deck-type-terms">–¢–æ–ª—å–∫–æ —Ç–µ—Ä–º–∏–Ω—ã</option>
                    <option value="problems" data-lang-key="deck-type-problems">–¢–æ–ª—å–∫–æ –∑–∞–¥–∞—á–∏</option>
                    <option value="combined" data-lang-key="deck-type-combined">–¢–µ—Ä–º–∏–Ω—ã –∏ –∑–∞–¥–∞—á–∏</option>
                </select>
                <div class="add-card-section" id="termsSection">
                    <h3 data-lang-key="add-cards-terms-header">–î–æ–±–∞–≤–∏—Ç—å –¢–µ—Ä–º–∏–Ω—ã</h3>
                    <div id="termsInputContainer"></div>
                    <button type="button" id="addAnotherTermBtn" class="button-outline" data-lang-key="add-another-card">–î–æ–±–∞–≤–∏—Ç—å –µ—â–µ —Ç–µ—Ä–º–∏–Ω</button>
                </div>
                <div class="add-card-section" id="problemsSection" style="display: none;">
                    <h3 data-lang-key="add-cards-problems-header">–î–æ–±–∞–≤–∏—Ç—å –ó–∞–¥–∞—á–∏</h3>
                    <div id="problemsInputContainer"></div>
                    <button type="button" id="addAnotherProblemBtn" class="button-outline" data-lang-key="add-another-problem">–î–æ–±–∞–≤–∏—Ç—å –µ—â–µ –∑–∞–¥–∞—á—É</button>
                </div>
                <button type="submit" class="button-style" data-lang-key="save-deck">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–ª–æ–¥—É</button>
            </form>
        </div>
    </div>

     <div class="modal" id="achievementsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 data-lang-key="achievements-modal-title">–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è</h2>
                <button class="close-modal" id="closeAchievementsModal" aria-label="–ó–∞–∫—Ä—ã—Ç—å" title="–ó–∞–∫—Ä—ã—Ç—å">&times;</button>
            </div>
            <ul id="achievementsList">
                <li class="no-achievements" data-lang-key="no-achievements-yet">–í—ã –ø–æ–∫–∞ –Ω–µ –ø–æ–ª—É—á–∏–ª–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π.</li>
            </ul>
        </div>
    </div>


    <div class="badge-earned" id="badgeNotification">
        <div class="badge-icon">üèÜ</div>
        <h3 data-lang-key="achievement-unlocked">–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ!</h3>
        <p id="badgeDescription" data-lang-key="new-badge">–í—ã –ø–æ–ª—É—á–∏–ª–∏ –∑–Ω–∞—á–æ–∫!</p>
    </div>

    <footer>
        <p data-lang-key="footer-text">¬© 2025 –§–∏–∑–∏–∫–∞: –ö–∞—Ä—Ç–æ—á–∫–∏ –∏ –ó–∞–¥–∞—á–∏ | –°–æ–∑–¥–∞–Ω–æ –≤ –æ–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö —Ü–µ–ª—è—Ö</p>
    </footer>

    <script>
        // --- Language Packs (Added keys) ---
        const languages = {
            en: {
                "html-title": "Physics: Flashcards & Problems", "header-title": "Physics: Flashcards & Problems", "header-subtitle": "Interactive Physics Learning",
                "choose-deck": "Choose Deck", "create-deck": "Create Deck", "mode-flashcards": "Terms", "mode-flashcards-desc": "Learn concepts",
                "mode-quiz": "Quiz", "mode-quiz-desc": "Test knowledge", "mode-problems": "Problems", "mode-problems-desc": "Solve problems",
                "start-title": "Let's start!", "start-content": "Choose a deck to begin.", "ready-title": "Ready?", "ready-content": "Press 'Next'.",
                "submit-answer": "Submit Answer", "previous": "Previous", "next": "Next", "flip-card": "Flip Card", "shuffle": "Shuffle",
                "original-order": "Original Order", "learning-progress": "Learning Progress", "cards-reviewed": "Reviewed", "correct-answers": "Correct",
                "total-attempts": "Attempts", "accuracy-rate": "Accuracy", "current-streak": "Streak", "reset-stats": "Reset", "choose-deck-modal": "Choose a Deck",
                "create-new-deck-modal": "Create New Deck", "deck-title-label": "Deck Title:", "deck-desc-label": "Description:", "deck-type-label": "Deck Type:",
                "deck-type-terms": "Terms Only", "deck-type-problems": "Problems Only", "deck-type-combined": "Terms and Problems",
                "add-cards-terms-header": "Add Terms", "add-another-card": "Add Another Term", "add-cards-problems-header": "Add Problems",
                "add-another-problem": "Add Another Problem",
                "card-front-title-label": "Term/Topic:", "card-front-content-label": "Prompt/Definition:", "card-back-formula-label": "Formula:", "card-back-units-label": "Units:", "card-back-vars-label": "Variables:", "card-back-content-label": "Explanation:",
                "problem-title-label": "Problem Title:", "problem-content-label": "Problem:", "problem-answer-label": "Answer (Number):",
                "save-deck": "Save Deck", "achievement-unlocked": "Achievement Unlocked!",
                "new-badge": "You earned a new badge!", "streak-title": "Streak!", "streak-5-desc": "5 correct answers in a row!",
                "streak-10-desc": "10 correct answers in a row! Amazing!", "deck-completed-title": "Deck Completed!",
                "deck-completed-desc": "You've studied all cards in this deck.", "correct-feedback": "Correct! ‚úì",
                "incorrect-feedback": "Incorrect ‚úó The correct answer was:", "problem-input-label": "Enter answer (number):", "input-placeholder": "0",
                "footer-text": "¬© 2025 Physics: Flashcards & Problems | Created for educational purposes", "no-decks-available": "No decks available. Create one!",
                "select-language": "Select Language", "toggle-theme": "Toggle theme", "confirm-delete": "Delete deck", "deck-title-required": "Deck title is required.",
                "add-one-card-alert": "Add at least one valid term or problem.", "deck-created-success": "Deck", "created-successfully": "created successfully!",
                "one-card-required-alert": "At least one card is required.", "term-header": "Term", "delete-term": "Delete Term", "problem-header": "Problem",
                "delete-problem": "Delete Problem", "no-options": "No options available.",
                "achievements": "üèÜ Achievements", "achievements-modal-title": "Achievements", "no-achievements-yet": "You haven't earned any achievements yet.", "current-deck-label": "Current Deck:", // New keys
                "perfection-quiz-title": "Perfection (Quiz)", "perfection-quiz-desc": "Answered all quiz questions correctly in one session!", // Perfection badge keys
                "perfection-problems-title": "Perfection (Problems)", "perfection-problems-desc": "Answered all problems correctly in one session!"
            },
            ru: {
                "html-title": "–§–∏–∑–∏–∫–∞: –ö–∞—Ä—Ç–æ—á–∫–∏ –∏ –ó–∞–¥–∞—á–∏", "header-title": "–§–∏–∑–∏–∫–∞: –ö–∞—Ä—Ç–æ—á–∫–∏ –∏ –ó–∞–¥–∞—á–∏", "header-subtitle": "–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –∏–∑—É—á–µ–Ω–∏–µ —Ñ–∏–∑–∏–∫–∏",
                "choose-deck": "–í—ã–±—Ä–∞—Ç—å –∫–æ–ª–æ–¥—É", "create-deck": "–°–æ–∑–¥–∞—Ç—å –∫–æ–ª–æ–¥—É", "mode-flashcards": "–¢–µ—Ä–º–∏–Ω—ã", "mode-flashcards-desc": "–ò–∑—É—á–µ–Ω–∏–µ –ø–æ–Ω—è—Ç–∏–π",
                "mode-quiz": "–¢–µ—Å—Ç", "mode-quiz-desc": "–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–Ω–∞–Ω–∏–π", "mode-problems": "–ó–∞–¥–∞—á–∏", "mode-problems-desc": "–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á",
                "start-title": "–ù–∞—á–Ω–µ–º!", "start-content": "–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–æ–¥—É –¥–ª—è –∏–∑—É—á–µ–Ω–∏—è.", "ready-title": "–ì–æ—Ç–æ–≤—ã?", "ready-content": "–ù–∞–∂–º–∏—Ç–µ '–î–∞–ª–µ–µ'.",
                "submit-answer": "–û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç", "previous": "–ù–∞–∑–∞–¥", "next": "–î–∞–ª–µ–µ", "flip-card": "–ü–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—å", "shuffle": "–ü–µ—Ä–µ–º–µ—à–∞—Ç—å",
                "original-order": "–ü–æ –ø–æ—Ä—è–¥–∫—É", "learning-progress": "–ü—Ä–æ–≥—Ä–µ—Å—Å –æ–±—É—á–µ–Ω–∏—è", "cards-reviewed": "–ü—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–æ", "correct-answers": "–ü—Ä–∞–≤–∏–ª—å–Ω–æ",
                "total-attempts": "–ü–æ–ø—ã—Ç–æ–∫", "accuracy-rate": "–¢–æ—á–Ω–æ—Å—Ç—å", "current-streak": "–°–µ—Ä–∏—è", "reset-stats": "–°–±—Ä–æ—Å–∏—Ç—å", "choose-deck-modal": "–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–æ–¥—É",
                "create-new-deck-modal": "–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∫–æ–ª–æ–¥—É", "deck-title-label": "–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ª–æ–¥—ã:", "deck-desc-label": "–û–ø–∏—Å–∞–Ω–∏–µ:", "deck-type-label": "–¢–∏–ø –∫–æ–ª–æ–¥—ã:",
                "deck-type-terms": "–¢–æ–ª—å–∫–æ —Ç–µ—Ä–º–∏–Ω—ã", "deck-type-problems": "–¢–æ–ª—å–∫–æ –∑–∞–¥–∞—á–∏", "deck-type-combined": "–¢–µ—Ä–º–∏–Ω—ã –∏ –∑–∞–¥–∞—á–∏",
                "add-cards-terms-header": "–î–æ–±–∞–≤–∏—Ç—å –¢–µ—Ä–º–∏–Ω—ã", "add-another-card": "–î–æ–±–∞–≤–∏—Ç—å –µ—â–µ —Ç–µ—Ä–º–∏–Ω", "add-cards-problems-header": "–î–æ–±–∞–≤–∏—Ç—å –ó–∞–¥–∞—á–∏",
                "add-another-problem": "–î–æ–±–∞–≤–∏—Ç—å –µ—â–µ –∑–∞–¥–∞—á—É",
                "card-front-title-label": "–¢–µ–º–∞/–¢–µ—Ä–º–∏–Ω:", "card-front-content-label": "–í–æ–ø—Ä–æ—Å/–û–ø–∏—Å–∞–Ω–∏–µ:", "card-back-formula-label": "–§–æ—Ä–º—É–ª–∞:", "card-back-units-label": "–ï–¥. –∏–∑–º.:", "card-back-vars-label": "–û–±–æ–∑–Ω–∞—á–µ–Ω–∏—è:", "card-back-content-label": "–û–±—ä—è—Å–Ω–µ–Ω–∏–µ:",
                "problem-title-label": "–ù–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:", "problem-content-label": "–ó–∞–¥–∞—á–∞:", "problem-answer-label": "–û—Ç–≤–µ—Ç (—á–∏—Å–ª–æ):",
                "save-deck": "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–ª–æ–¥—É", "achievement-unlocked": "–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ!",
                "new-badge": "–í—ã –ø–æ–ª—É—á–∏–ª–∏ –∑–Ω–∞—á–æ–∫!", "streak-title": "–°–µ—Ä–∏—è!", "streak-5-desc": "5 –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ –ø–æ–¥—Ä—è–¥!",
                "streak-10-desc": "10 –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ –ø–æ–¥—Ä—è–¥! –û—Ç–ª–∏—á–Ω–æ!", "deck-completed-title": "–ö–æ–ª–æ–¥–∞ –∏–∑—É—á–µ–Ω–∞!",
                "deck-completed-desc": "–í—ã –ø—Ä–æ—à–ª–∏ –≤—Å–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –≤ —ç—Ç–æ–π –∫–æ–ª–æ–¥–µ.", "correct-feedback": "–ü—Ä–∞–≤–∏–ª—å–Ω–æ! ‚úì",
                "incorrect-feedback": "–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ ‚úó –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç:", "problem-input-label": "–í–≤–µ–¥–∏—Ç–µ –æ—Ç–≤–µ—Ç (—á–∏—Å–ª–æ):", "input-placeholder": "0",
                "footer-text": "¬© 2025 –§–∏–∑–∏–∫–∞: –ö–∞—Ä—Ç–æ—á–∫–∏ –∏ –ó–∞–¥–∞—á–∏ | –°–æ–∑–¥–∞–Ω–æ –≤ –æ–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö —Ü–µ–ª—è—Ö", "no-decks-available": "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–ª–æ–¥. –°–æ–∑–¥–∞–π—Ç–µ —Å–≤–æ—é!",
                "select-language": "–í—ã–±—Ä–∞—Ç—å —è–∑—ã–∫", "toggle-theme": "–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ç–µ–º—É", "confirm-delete": "–£–¥–∞–ª–∏—Ç—å –∫–æ–ª–æ–¥—É", "deck-title-required": "–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ª–æ–¥—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ.",
                "add-one-card-alert": "–î–æ–±–∞–≤—å—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –≤–∞–ª–∏–¥–Ω—ã–π —Ç–µ—Ä–º–∏–Ω –∏–ª–∏ –∑–∞–¥–∞—á—É.", "deck-created-success": "–ö–æ–ª–æ–¥–∞", "created-successfully": "—É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!",
                "one-card-required-alert": "–î–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–∞.", "term-header": "–¢–µ—Ä–º–∏–Ω", "delete-term": "–£–¥–∞–ª–∏—Ç—å –¢–µ—Ä–º–∏–Ω", "problem-header": "–ó–∞–¥–∞—á–∞",
                "delete-problem": "–£–¥–∞–ª–∏—Ç—å –ó–∞–¥–∞—á—É", "no-options": "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.",
                "achievements": "üèÜ –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è", "achievements-modal-title": "–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è", "no-achievements-yet": "–í—ã –ø–æ–∫–∞ –Ω–µ –ø–æ–ª—É—á–∏–ª–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π.", "current-deck-label": "–¢–µ–∫—É—â–∞—è –∫–æ–ª–æ–¥–∞:", // New keys
                "perfection-quiz-title": "–ë–µ–∑—É–ø—Ä–µ—á–Ω–æ—Å—Ç—å (–¢–µ—Å—Ç)", "perfection-quiz-desc": "–í—Å–µ –æ—Ç–≤–µ—Ç—ã –≤ —Ç–µ—Å—Ç–µ –≤–µ—Ä–Ω—ã –∑–∞ –æ–¥–Ω—É —Å–µ—Å—Å–∏—é!", // Perfection badge keys
                "perfection-problems-title": "–ë–µ–∑—É–ø—Ä–µ—á–Ω–æ—Å—Ç—å (–ó–∞–¥–∞—á–∏)", "perfection-problems-desc": "–í—Å–µ –∑–∞–¥–∞—á–∏ —Ä–µ—à–µ–Ω—ã –≤–µ—Ä–Ω–æ –∑–∞ –æ–¥–Ω—É —Å–µ—Å—Å–∏—é!"
            },
            es: {
                "html-title": "F√≠sica: Tarjetas y Problemas", "header-title": "F√≠sica: Tarjetas y Problemas", "header-subtitle": "Aprendizaje Interactivo de F√≠sica",
                "choose-deck": "Elegir Mazo", "create-deck": "Crear Mazo", "mode-flashcards": "T√©rminos", "mode-flashcards-desc": "Aprender conceptos",
                "mode-quiz": "Prueba", "mode-quiz-desc": "Evaluar conocimiento", "mode-problems": "Problemas", "mode-problems-desc": "Resolver problemas",
                "start-title": "¬°Empecemos!", "start-content": "Elige un mazo para empezar.", "ready-title": "¬øListo?", "ready-content": "Pulsa 'Siguiente'.",
                "submit-answer": "Enviar Respuesta", "previous": "Anterior", "next": "Siguiente", "flip-card": "Voltear Tarjeta", "shuffle": "Mezclar",
                "original-order": "Orden Original", "learning-progress": "Progreso de Aprendizaje", "cards-reviewed": "Revisadas", "correct-answers": "Correctas",
                "total-attempts": "Intentos", "accuracy-rate": "Precisi√≥n", "current-streak": "Racha", "reset-stats": "Reiniciar", "choose-deck-modal": "Elige un Mazo",
                "create-new-deck-modal": "Crear Nuevo Mazo", "deck-title-label": "T√≠tulo del Mazo:", "deck-desc-label": "Descripci√≥n:", "deck-type-label": "Tipo de Mazo:",
                "deck-type-terms": "Solo T√©rminos", "deck-type-problems": "Solo Problemas", "deck-type-combined": "T√©rminos y Problemas",
                "add-cards-terms-header": "A√±adir T√©rminos", "add-another-card": "A√±adir Otro T√©rmino", "add-cards-problems-header": "A√±adir Problemas",
                "add-another-problem": "A√±adir Otro Problema",
                 "card-front-title-label": "Tema/T√©rmino:", "card-front-content-label": "Pregunta/Descripci√≥n:", "card-back-formula-label": "F√≥rmula:", "card-back-units-label": "Unidades:", "card-back-vars-label": "Variables:", "card-back-content-label": "Explicaci√≥n:",
                 "problem-title-label": "T√≠tulo del Problema:", "problem-content-label": "Problema:", "problem-answer-label": "Respuesta (N√∫mero):",
                 "save-deck": "Guardar Mazo", "achievement-unlocked": "¬°Logro Desbloqueado!",
                "new-badge": "¬°Has ganado una nueva insignia!", "streak-title": "¬°Racha!", "streak-5-desc": "¬°5 respuestas correctas seguidas!",
                "streak-10-desc": "¬°10 respuestas correctas seguidas! ¬°Incre√≠ble!", "deck-completed-title": "¬°Mazo Completado!",
                "deck-completed-desc": "Has estudiado todas las tarjetas de este mazo.", "correct-feedback": "¬°Correcto! ‚úì",
                "incorrect-feedback": "Incorrecto ‚úó La respuesta correcta era:", "problem-input-label": "Introduce la respuesta (n√∫mero):", "input-placeholder": "0",
                "footer-text": "¬© 2025 F√≠sica: Tarjetas y Problemas | Creado con fines educativos", "no-decks-available": "No hay mazos disponibles. ¬°Crea uno!",
                "select-language": "Seleccionar idioma", "toggle-theme": "Alternar tema", "confirm-delete": "Eliminar mazo", "deck-title-required": "El t√≠tulo del mazo es obligatorio.",
                "add-one-card-alert": "A√±ade al menos un t√©rmino o problema v√°lido.", "deck-created-success": "Mazo", "created-successfully": "creado con √©xito!",
                "one-card-required-alert": "Se requiere al menos una tarjeta.", "term-header": "T√©rmino", "delete-term": "Eliminar T√©rmino", "problem-header": "Problema",
                "delete-problem": "Eliminar Problema", "no-options": "No hay opciones disponibles.",
                 "achievements": "üèÜ Logros", "achievements-modal-title": "Logros", "no-achievements-yet": "A√∫n no has conseguido ning√∫n logro.", "current-deck-label": "Mazo actual:", // New keys
                "perfection-quiz-title": "Perfecci√≥n (Prueba)", "perfection-quiz-desc": "¬°Respondiste correctamente todas las preguntas de la prueba en una sesi√≥n!", // Perfection badge keys
                "perfection-problems-title": "Perfecci√≥n (Problemas)", "perfection-problems-desc": "¬°Resolviste correctamente todos los problemas en una sesi√≥n!"
            }
        };

        // --- Deck Data (Example - Same as previous) ---
        const predefinedDecksMultiLang = {
            'physics-combined-ru': {
                ru: {
                    title: '–§–∏–∑–∏–∫–∞: –û—Å–Ω–æ–≤—ã',
                    description: '–ò–∑—É—á–∏—Ç–µ —Ç–µ—Ä–º–∏–Ω—ã –∏ —Ä–µ—à–∏—Ç–µ –∑–∞–¥–∞—á–∏',
                    deckType: 'combined',
                    termsCards: [
                        { front: { title: "–ü–µ—Ä–≤—ã–π –∑–∞–∫–æ–Ω –ù—å—é—Ç–æ–Ω–∞", content: "–°—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π—Ç–µ –∑–∞–∫–æ–Ω –∏–Ω–µ—Ä—Ü–∏–∏."}, back: { title: "–ó–∞–∫–æ–Ω –ò–Ω–µ—Ä—Ü–∏–∏", formula:"$\\vec{F}_{net} = 0 \\implies \\vec{v} = const$", units:"–°–∫–æ—Ä–æ—Å—Ç—å (–º/—Å)", vars:"$\\vec{F}_{net}$ - —Ä–∞–≤–Ω–æ–¥–µ–π—Å—Ç–≤—É—é—â–∞—è —Å–∏–ª–∞, $\\vec{v}$ - —Å–∫–æ—Ä–æ—Å—Ç—å", content: "–°—É—â–µ—Å—Ç–≤—É—é—Ç —Ç–∞–∫–∏–µ —Å–∏—Å—Ç–µ–º—ã –æ—Ç—Å—á–µ—Ç–∞ (–∏–Ω–µ—Ä—Ü–∏–∞–ª—å–Ω—ã–µ), –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–æ—Ç–æ—Ä—ã—Ö —Ç–µ–ª–æ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–≤–æ—é —Å–∫–æ—Ä–æ—Å—Ç—å –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π, –µ—Å–ª–∏ –Ω–∞ –Ω–µ–≥–æ –Ω–µ –¥–µ–π—Å—Ç–≤—É—é—Ç –¥—Ä—É–≥–∏–µ —Ç–µ–ª–∞ –∏–ª–∏ –¥–µ–π—Å—Ç–≤–∏–µ —ç—Ç–∏—Ö —Ç–µ–ª —Å–∫–æ–º–ø–µ–Ω—Å–∏—Ä–æ–≤–∞–Ω–æ."}},
                         { front: { title: "–í—Ç–æ—Ä–æ–π –∑–∞–∫–æ–Ω –ù—å—é—Ç–æ–Ω–∞", content: "–û—Å–Ω–æ–≤–Ω–æ–π –∑–∞–∫–æ–Ω –¥–∏–Ω–∞–º–∏–∫–∏."}, back: { title: "F = ma", formula:"$\\vec{F}_{net} = m\\vec{a}$", units:"–°–∏–ª–∞ (–ù), –º–∞—Å—Å–∞ (–∫–≥), —É—Å–∫–æ—Ä–µ–Ω–∏–µ (–º/—Å¬≤)", vars:"$\\vec{F}_{net}$ - —Ä–∞–≤–Ω–æ–¥–µ–π—Å—Ç–≤—É—é—â–∞—è —Å–∏–ª–∞, m - –º–∞—Å—Å–∞, $\\vec{a}$ - —É—Å–∫–æ—Ä–µ–Ω–∏–µ", content: "–£—Å–∫–æ—Ä–µ–Ω–∏–µ —Ç–µ–ª–∞ –ø—Ä—è–º–æ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ —Ä–∞–≤–Ω–æ–¥–µ–π—Å—Ç–≤—É—é—â–µ–π —Å–∏–ª, –ø—Ä–∏–ª–æ–∂–µ–Ω–Ω—ã—Ö –∫ —Ç–µ–ª—É, –∏ –æ–±—Ä–∞—Ç–Ω–æ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –µ–≥–æ –º–∞—Å—Å–µ."}},
                         { front: { title: "–¢—Ä–µ—Ç–∏–π –∑–∞–∫–æ–Ω –ù—å—é—Ç–æ–Ω–∞", content: "–ó–∞–∫–æ–Ω –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Ç–µ–ª."}, back: { title: "–î–µ–π—Å—Ç–≤–∏–µ = –ü—Ä–æ—Ç–∏–≤–æ–¥–µ–π—Å—Ç–≤–∏–µ", formula:"$\\vec{F}_{12} = -\\vec{F}_{21}$", units:"–°–∏–ª–∞ (–ù)", vars:"$\\vec{F}_{12}$ - —Å–∏–ª–∞, –¥–µ–π—Å—Ç–≤—É—é—â–∞—è –Ω–∞ —Ç–µ–ª–æ 1 —Å–æ —Å—Ç–æ—Ä–æ–Ω—ã —Ç–µ–ª–∞ 2", content: "–°–∏–ª—ã, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –¥–≤–∞ —Ç–µ–ª–∞ –¥–µ–π—Å—Ç–≤—É—é—Ç –¥—Ä—É–≥ –Ω–∞ –¥—Ä—É–≥–∞, —Ä–∞–≤–Ω—ã –ø–æ –º–æ–¥—É–ª—é –∏ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é."}},
                         { front: { title: "–ó–∞–∫–æ–Ω –≤—Å–µ–º–∏—Ä–Ω–æ–≥–æ —Ç—è–≥–æ—Ç–µ–Ω–∏—è", content: "–ö–∞–∫ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤—É—é—Ç –º–∞—Å—Å—ã?"}, back: { title: "–ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è", formula:"$F = G \\frac{m_1 m_2}{r^2}$", units:"–°–∏–ª–∞ (–ù), –º–∞—Å—Å–∞ (–∫–≥), —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ (–º)", vars:"G - –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–æ—Å—Ç–æ—è–Ω–Ω–∞—è ($‚âà 6.67 \\times 10^{-11}$ –ù¬∑–º¬≤/–∫–≥¬≤), $m_1, m_2$ - –º–∞—Å—Å—ã —Ç–µ–ª, r - —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ", content: "–î–≤–∞ –ª—é–±—ã—Ö —Ç–µ–ª–∞ –ø—Ä–∏—Ç—è–≥–∏–≤–∞—é—Ç—Å—è –¥—Ä—É–≥ –∫ –¥—Ä—É–≥—É —Å —Å–∏–ª–æ–π, –ø—Ä—è–º–æ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—é –∏—Ö –º–∞—Å—Å –∏ –æ–±—Ä–∞—Ç–Ω–æ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –∫–≤–∞–¥—Ä–∞—Ç—É —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É –Ω–∏–º–∏."}},
                         { front: { title: "–í–µ—Å —Ç–µ–ª–∞", content: "–°–∏–ª–∞ –¥–∞–≤–ª–µ–Ω–∏—è –Ω–∞ –æ–ø–æ—Ä—É."}, back: { title: "P = mg (–≤ –ø–æ–∫–æ–µ)", formula:"$\\vec{P} = m(\\vec{g} - \\vec{a})$", units:"–í–µ—Å (–ù), –º–∞—Å—Å–∞ (–∫–≥), —É—Å–∫–æ—Ä–µ–Ω–∏–µ (–º/—Å¬≤)", vars:"m - –º–∞—Å—Å–∞, $\\vec{g}$ - —É—Å–∫–æ—Ä–µ–Ω–∏–µ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –ø–∞–¥–µ–Ω–∏—è, $\\vec{a}$ - —É—Å–∫–æ—Ä–µ–Ω–∏–µ –æ–ø–æ—Ä—ã/–ø–æ–¥–≤–µ—Å–∞", content: "–°–∏–ª–∞, —Å –∫–æ—Ç–æ—Ä–æ–π —Ç–µ–ª–æ –≤—Å–ª–µ–¥—Å—Ç–≤–∏–µ –ø—Ä–∏—Ç—è–∂–µ–Ω–∏—è –∫ –ó–µ–º–ª–µ –¥–µ–π—Å—Ç–≤—É–µ—Ç –Ω–∞ –æ–ø–æ—Ä—É –∏–ª–∏ –ø–æ–¥–≤–µ—Å. –ù–µ –ø—É—Ç–∞—Ç—å —Å –º–∞—Å—Å–æ–π!"}},
                         { front: { title: "–ò–º–ø—É–ª—å—Å —Ç–µ–ª–∞", content: "–ú–µ—Ä–∞ –º–µ—Ö–∞–Ω–∏—á–µ—Å–∫–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è."}, back: { title: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–≤–∏–∂–µ–Ω–∏—è", formula:"$\\vec{p} = m\\vec{v}$", units:"–∫–≥¬∑–º/—Å", vars:"m - –º–∞—Å—Å–∞, $\\vec{v}$ - —Å–∫–æ—Ä–æ—Å—Ç—å", content: "–í–µ–∫—Ç–æ—Ä–Ω–∞—è —Ñ–∏–∑–∏—á–µ—Å–∫–∞—è –≤–µ–ª–∏—á–∏–Ω–∞, —Ä–∞–≤–Ω–∞—è –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—é –º–∞—Å—Å—ã —Ç–µ–ª–∞ –Ω–∞ –µ–≥–æ —Å–∫–æ—Ä–æ—Å—Ç—å."}},
                         { front: { title: "–ò–º–ø—É–ª—å—Å —Å–∏–ª—ã", content: "–ú–µ—Ä–∞ –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏—è —Å–∏–ª—ã –∑–∞ –≤—Ä–µ–º—è."}, back: { title: "–ò–∑–º–µ–Ω–µ–Ω–∏–µ –∏–º–ø—É–ª—å—Å–∞ —Ç–µ–ª–∞", formula:"$\\Delta \\vec{p} = \\vec{F} \\Delta t$", units:"–ù¬∑—Å –∏–ª–∏ –∫–≥¬∑–º/—Å", vars:"$\\vec{F}$ - —Å–∏–ª–∞, $\\Delta t$ - –≤—Ä–µ–º—è –¥–µ–π—Å—Ç–≤–∏—è —Å–∏–ª—ã", content: "–ü—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Å–∏–ª—ã –Ω–∞ –≤—Ä–µ–º—è –µ–µ –¥–µ–π—Å—Ç–≤–∏—è, —Ä–∞–≤–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏—é –∏–º–ø—É–ª—å—Å–∞ —Ç–µ–ª–∞."}},
                         { front: { title: "–ó–∞–∫–æ–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–º–ø—É–ª—å—Å–∞", content: "–ß—Ç–æ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –∑–∞–º–∫–Ω—É—Ç–æ–π —Å–∏—Å—Ç–µ–º–µ?"}, back: { title: "–°—É–º–º–∞—Ä–Ω—ã–π –∏–º–ø—É–ª—å—Å", formula:"$\\sum \\vec{p}_{–¥–æ} = \\sum \\vec{p}_{–ø–æ—Å–ª–µ}$", units:"–∫–≥¬∑–º/—Å", vars:"$\\vec{p}$ - –∏–º–ø—É–ª—å—Å —Ç–µ–ª–∞", content: "–í –∑–∞–º–∫–Ω—É—Ç–æ–π —Å–∏—Å—Ç–µ–º–µ —Ç–µ–ª –≤–µ–∫—Ç–æ—Ä–Ω–∞—è —Å—É–º–º–∞ –∏–º–ø—É–ª—å—Å–æ–≤ –≤—Å–µ—Ö —Ç–µ–ª —Å–∏—Å—Ç–µ–º—ã –æ—Å—Ç–∞–µ—Ç—Å—è –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π –ø—Ä–∏ –ª—é–±—ã—Ö –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è—Ö —Ç–µ–ª —ç—Ç–æ–π —Å–∏—Å—Ç–µ–º—ã –º–µ–∂–¥—É —Å–æ–±–æ–π."}},
                         { front: { title: "–ö–∏–Ω–µ—Ç–∏—á–µ—Å–∫–∞—è —ç–Ω–µ—Ä–≥–∏—è", content: "–≠–Ω–µ—Ä–≥–∏—è –¥–≤–∏–∂—É—â–µ–≥–æ—Å—è —Ç–µ–ª–∞."}, back: { title: "–≠–Ω–µ—Ä–≥–∏—è –¥–≤–∏–∂–µ–Ω–∏—è", formula:"$E_k = \\frac{mv^2}{2}$", units:"–î–∂–æ—É–ª—å (–î–∂)", vars:"m - –º–∞—Å—Å–∞ (–∫–≥), v - —Å–∫–æ—Ä–æ—Å—Ç—å (–º/—Å)", content: "–≠–Ω–µ—Ä–≥–∏—è, –∫–æ—Ç–æ—Ä–æ–π –æ–±–ª–∞–¥–∞–µ—Ç —Ç–µ–ª–æ –≤—Å–ª–µ–¥—Å—Ç–≤–∏–µ —Å–≤–æ–µ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è."}},
                         { front: { title: "–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è (—Ç—è–≥–æ—Ç–µ–Ω–∏—è)", content: "–≠–Ω–µ—Ä–≥–∏—è –ø–æ–ª–æ–∂–µ–Ω–∏—è –≤ –ø–æ–ª–µ —Ç—è–∂–µ—Å—Ç–∏."}, back: { title: "–≠–Ω–µ—Ä–≥–∏—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è", formula:"$E_p = mgh$", units:"–î–∂–æ—É–ª—å (–î–∂)", vars:"m - –º–∞—Å—Å–∞ (–∫–≥), g - —É—Å–∫–æ—Ä–µ–Ω–∏–µ —Å–≤–æ–±. –ø–∞–¥–µ–Ω–∏—è (–º/—Å¬≤), h - –≤—ã—Å–æ—Ç–∞ (–º)", content: "–≠–Ω–µ—Ä–≥–∏—è, –æ–±—É—Å–ª–æ–≤–ª–µ–Ω–Ω–∞—è –≤–∑–∞–∏–º–Ω—ã–º —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ–º —Ç–µ–ª –∏–ª–∏ —á–∞—Å—Ç–µ–π –æ–¥–Ω–æ–≥–æ —Ç–µ–ª–∞ –≤ –ø–æ–ª–µ —Ç—è–≥–æ—Ç–µ–Ω–∏—è –ó–µ–º–ª–∏ (–ø—Ä–∏ h << R_–∑–µ–º–ª–∏)."}},
                         { front: { title: "–ó–∞–∫–æ–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —ç–Ω–µ—Ä–≥–∏–∏", content: "–§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π –∑–∞–∫–æ–Ω –ø—Ä–∏—Ä–æ–¥—ã."}, back: { title: "–ü–æ–ª–Ω–∞—è –º–µ—Ö–∞–Ω–∏—á–µ—Å–∫–∞—è —ç–Ω–µ—Ä–≥–∏—è", formula:"$E_k + E_p = const$ (–¥–ª—è –∑–∞–º–∫–Ω—É—Ç–æ–π –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã)", units:"–î–∂–æ—É–ª—å (–î–∂)", vars:"$E_k$ - –∫–∏–Ω–µ—Ç–∏—á–µ—Å–∫–∞—è, $E_p$ - –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è", content: "–ü–æ–ª–Ω–∞—è –º–µ—Ö–∞–Ω–∏—á–µ—Å–∫–∞—è —ç–Ω–µ—Ä–≥–∏—è –∑–∞–º–∫–Ω—É—Ç–æ–π —Å–∏—Å—Ç–µ–º—ã —Ç–µ–ª, –≤ –∫–æ—Ç–æ—Ä–æ–π –¥–µ–π—Å—Ç–≤—É—é—Ç —Ç–æ–ª—å–∫–æ –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–µ —Å–∏–ª—ã (—Ç—è–≥–æ—Ç–µ–Ω–∏—è, —É–ø—Ä—É–≥–æ—Å—Ç–∏), –æ—Å—Ç–∞–µ—Ç—Å—è –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π."}},
                         { front: { title: "–î–ª–∏–Ω–∞ –≤–æ–ª–Ω—ã", content: "–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É '–≥—Ä–µ–±–Ω—è–º–∏'."}, back: { title: "Œª", formula:"$\\lambda = vT = \\frac{v}{f}$", units:"–º–µ—Ç—Ä (–º)", vars:"v - —Å–∫–æ—Ä–æ—Å—Ç—å –≤–æ–ª–Ω—ã (–º/—Å), T - –ø–µ—Ä–∏–æ–¥ (—Å), f - —á–∞—Å—Ç–æ—Ç–∞ (–ì—Ü)", content: "–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –¥–≤—É–º—è –±–ª–∏–∂–∞–π—à–∏–º–∏ —Ç–æ—á–∫–∞–º–∏, –∫–æ–ª–µ–±–ª—é—â–∏–º–∏—Å—è –≤ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π —Ñ–∞–∑–µ."}},
                         { front: { title: "–ß–∞—Å—Ç–æ—Ç–∞ –∫–æ–ª–µ–±–∞–Ω–∏–π", content: "–ö–∞–∫ —á–∞—Å—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥—è—Ç –∫–æ–ª–µ–±–∞–Ω–∏—è?"}, back: { title: "f –∏–ª–∏ ŒΩ", formula:"$f = \\frac{1}{T}$", units:"–ì–µ—Ä—Ü (–ì—Ü)", vars:"T - –ø–µ—Ä–∏–æ–¥ –∫–æ–ª–µ–±–∞–Ω–∏–π (—Å)", content: "–ß–∏—Å–ª–æ –ø–æ–ª–Ω—ã—Ö –∫–æ–ª–µ–±–∞–Ω–∏–π, —Å–æ–≤–µ—Ä—à–∞–µ–º—ã—Ö –∑–∞ –µ–¥–∏–Ω–∏—Ü—É –≤—Ä–µ–º–µ–Ω–∏."}},
                         { front: { title: "–°–∫–æ—Ä–æ—Å—Ç—å —Å–≤–µ—Ç–∞ –≤ –≤–∞–∫—É—É–º–µ", content: "–ü—Ä–µ–¥–µ–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å."}, back: { title: "c", formula:"$c \\approx 3 \\times 10^8$ –º/—Å", units:"–º/—Å", vars:"c - —Å–∫–æ—Ä–æ—Å—Ç—å —Å–≤–µ—Ç–∞", content: "–§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–∞—è —Ñ–∏–∑–∏—á–µ—Å–∫–∞—è –ø–æ—Å—Ç–æ—è–Ω–Ω–∞—è, –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–π."}},
                         { front: { title: "–ú–æ—â–Ω–æ—Å—Ç—å", content: "–°–∫–æ—Ä–æ—Å—Ç—å —Å–æ–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã."}, back: { title: "N –∏–ª–∏ P", formula:"$N = \\frac{A}{t} = Fv \\cos(\\alpha)$", units:"–í–∞—Ç—Ç (–í—Ç)", vars:"A - —Ä–∞–±–æ—Ç–∞ (–î–∂), t - –≤—Ä–µ–º—è (—Å), F - —Å–∏–ª–∞ (–ù), v - —Å–∫–æ—Ä–æ—Å—Ç—å (–º/—Å)", content: "–§–∏–∑–∏—á–µ—Å–∫–∞—è –≤–µ–ª–∏—á–∏–Ω–∞, —Ä–∞–≤–Ω–∞—è –æ—Ç–Ω–æ—à–µ–Ω–∏—é —Ä–∞–±–æ—Ç—ã, —Å–æ–≤–µ—Ä—à–∞–µ–º–æ–π –∑–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã–π –ø—Ä–æ–º–µ–∂—É—Ç–æ–∫ –≤—Ä–µ–º–µ–Ω–∏, –∫ —ç—Ç–æ–º—É –ø—Ä–æ–º–µ–∂—É—Ç–∫—É –≤—Ä–µ–º–µ–Ω–∏."}},
                         { front: { title: "–†–∞–±–æ—Ç–∞ —Å–∏–ª—ã", content: "–ú–µ—Ä–∞ –¥–µ–π—Å—Ç–≤–∏—è —Å–∏–ª—ã –ø–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—é."}, back: { title: "A", formula:"$A = Fs \\cos(\\alpha)$", units:"–î–∂–æ—É–ª—å (–î–∂)", vars:"F - —Å–∏–ª–∞ (–ù), s - –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ (–º), Œ± - —É–≥–æ–ª –º–µ–∂–¥—É —Å–∏–ª–æ–π –∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ–º", content: "–°–∫–∞–ª—è—Ä–Ω–∞—è —Ñ–∏–∑–∏—á–µ—Å–∫–∞—è –≤–µ–ª–∏—á–∏–Ω–∞, —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏–∑—É—é—â–∞—è –∏–∑–º–µ–Ω–µ–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏ —Å–∏—Å—Ç–µ–º—ã –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ –¥–µ–π—Å—Ç–≤–∏—è –Ω–∞ –Ω–µ–µ —Å–∏–ª—ã."}},
                         { front: { title: "–£—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ç–µ–ø–ª–æ–≤–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞", content: "–¢–µ–ø–ª–æ–æ–±–º–µ–Ω –≤ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ."}, back: { title: "Q_–æ—Ç–¥ + Q_–ø–æ–ª = 0", formula:"$\\sum Q_i = 0$", units:"–î–∂–æ—É–ª—å (–î–∂)", vars:"Q - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–µ–ø–ª–æ—Ç—ã", content: "–í –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ, –≤ –∫–æ—Ç–æ—Ä–æ–π –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ç–µ–ø–ª–æ–æ–±–º–µ–Ω, —Å—É–º–º–∞—Ä–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–µ–ø–ª–æ—Ç—ã, –æ—Ç–¥–∞–Ω–Ω–æ–µ –±–æ–ª–µ–µ –Ω–∞–≥—Ä–µ—Ç—ã–º–∏ —Ç–µ–ª–∞–º–∏, —Ä–∞–≤–Ω–æ —Å—É–º–º–∞—Ä–Ω–æ–º—É –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —Ç–µ–ø–ª–æ—Ç—ã, –ø–æ–ª—É—á–µ–Ω–Ω–æ–º—É –º–µ–Ω–µ–µ –Ω–∞–≥—Ä–µ—Ç—ã–º–∏ —Ç–µ–ª–∞–º–∏."}},
                         { front: { title: "–ó–∞–∫–æ–Ω –û–º–∞ –¥–ª—è —É—á–∞—Å—Ç–∫–∞ —Ü–µ–ø–∏", content: "–°–≤—è–∑—å —Ç–æ–∫–∞, –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è –∏ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è."}, back: { title: "I = U / R", formula:"$I = \\frac{U}{R}$", units:"–¢–æ–∫ (–ê), –ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ (–í), –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ (–û–º)", vars:"I - —Å–∏–ª–∞ —Ç–æ–∫–∞, U - –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ, R - —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ", content: "–°–∏–ª–∞ —Ç–æ–∫–∞ –Ω–∞ —É—á–∞—Å—Ç–∫–µ —Ü–µ–ø–∏ –ø—Ä—è–º–æ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–∞ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—é –Ω–∞ –∫–æ–Ω—Ü–∞—Ö —ç—Ç–æ–≥–æ —É—á–∞—Å—Ç–∫–∞ –∏ –æ–±—Ä–∞—Ç–Ω–æ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–∞ –µ–≥–æ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—é."}},
                         { front: { title: "–ó–∞–∫–æ–Ω –ö—É–ª–æ–Ω–∞", content: "–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Ç–æ—á–µ—á–Ω—ã—Ö –∑–∞—Ä—è–¥–æ–≤."}, back: { title: "–°–∏–ª–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –∑–∞—Ä—è–¥–æ–≤", formula:"$F = k \\frac{|q_1 q_2|}{r^2}$", units:"–°–∏–ª–∞ (–ù), –∑–∞—Ä—è–¥ (–ö–ª), —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ (–º)", vars:"k - –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ ($‚âà 9 \\times 10^9$ –ù¬∑–º¬≤/–ö–ª¬≤), $q_1, q_2$ - –≤–µ–ª–∏—á–∏–Ω—ã –∑–∞—Ä—è–¥–æ–≤, r - —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ", content: "–°–∏–ª–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –¥–≤—É—Ö –Ω–µ–ø–æ–¥–≤–∏–∂–Ω—ã—Ö —Ç–æ—á–µ—á–Ω—ã—Ö –∑–∞—Ä—è–¥–æ–≤ –≤ –≤–∞–∫—É—É–º–µ –ø—Ä—è–º–æ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–∞ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—é –º–æ–¥—É–ª–µ–π —ç—Ç–∏—Ö –∑–∞—Ä—è–¥–æ–≤ –∏ –æ–±—Ä–∞—Ç–Ω–æ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–∞ –∫–≤–∞–¥—Ä–∞—Ç—É —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É –Ω–∏–º–∏."}},
                         { front: { title: "–≠–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–∏–π —Ç–æ–∫", content: "–£–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –∑–∞—Ä—è–¥–æ–≤."}, back: { title: "–°–∏–ª–∞ —Ç–æ–∫–∞", formula:"$I = \\frac{\\Delta q}{\\Delta t}$", units:"–ê–º–ø–µ—Ä (–ê)", vars:"$\\Delta q$ - –∑–∞—Ä—è–¥ (–ö–ª), –ø—Ä–æ—à–µ–¥—à–∏–π —á–µ—Ä–µ–∑ –ø–æ–ø–µ—Ä–µ—á–Ω–æ–µ —Å–µ—á–µ–Ω–∏–µ –ø—Ä–æ–≤–æ–¥–Ω–∏–∫–∞, $\\Delta t$ - –≤—Ä–µ–º—è (—Å)", content: "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–µ (—É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω–æ–µ) –¥–≤–∏–∂–µ–Ω–∏–µ –∑–∞—Ä—è–∂–µ–Ω–Ω—ã—Ö —á–∞—Å—Ç–∏—Ü. –°–∏–ª–∞ —Ç–æ–∫–∞ - —Å–∫–∞–ª—è—Ä–Ω–∞—è –≤–µ–ª–∏—á–∏–Ω–∞, —Ä–∞–≤–Ω–∞—è –æ—Ç–Ω–æ—à–µ–Ω–∏—é –∑–∞—Ä—è–¥–∞, –ø—Ä–æ—à–µ–¥—à–µ–≥–æ —á–µ—Ä–µ–∑ —Å–µ—á–µ–Ω–∏–µ –ø—Ä–æ–≤–æ–¥–Ω–∏–∫–∞, –∫–æ –≤—Ä–µ–º–µ–Ω–∏ –µ–≥–æ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è."}}
                    ],
                    problemsCards: [ /* ... (10 –∫–∞—Ä—Ç–æ—á–µ–∫ –∑–∞–¥–∞—á –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —à–∞–≥–∞) ... */
                          { front: { title: "–ó–∞–¥–∞—á–∞: –°–∫–æ—Ä–æ—Å—Ç—å", content: "–ê–≤—Ç–æ–º–æ–±–∏–ª—å –ø—Ä–æ–µ—Ö–∞–ª 180 –∫–º –∑–∞ 2 —á–∞—Å–∞. –ö–∞–∫–æ–≤–∞ –µ–≥–æ —Å—Ä–µ–¥–Ω—è—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤ –∫–º/—á?" }, back: { content: "90" } },
                          { front: { title: "–ó–∞–¥–∞—á–∞: –°–∏–ª–∞ (2 –∑–∞–∫–æ–Ω –ù—å—é—Ç–æ–Ω–∞)", content: "–¢–µ–ª–æ –º–∞—Å—Å–æ–π 5 –∫–≥ –¥–≤–∏–∂–µ—Ç—Å—è —Å —É—Å–∫–æ—Ä–µ–Ω–∏–µ–º 3 –º/—Å¬≤. –ö–∞–∫–∞—è —Å–∏–ª–∞ –¥–µ–π—Å—Ç–≤—É–µ—Ç –Ω–∞ —Ç–µ–ª–æ (–≤ –ù)?" }, back: { content: "15" } },
                          { front: { title: "–ó–∞–¥–∞—á–∞: –†–∞–±–æ—Ç–∞", content: "–°–∏–ª–∞ 20 –ù –ø–µ—Ä–µ–º–µ—Å—Ç–∏–ª–∞ —Ç–µ–ª–æ –Ω–∞ 5 –º –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ —Å–∏–ª—ã. –ö–∞–∫–∞—è —Ä–∞–±–æ—Ç–∞ —Å–æ–≤–µ—Ä—à–µ–Ω–∞ (–≤ –î–∂)?" }, back: { content: "100" } },
                          { front: { title: "–ó–∞–¥–∞—á–∞: –ö–∏–Ω–µ—Ç–∏—á–µ—Å–∫–∞—è —ç–Ω–µ—Ä–≥–∏—è", content: "–¢–µ–ª–æ –º–∞—Å—Å–æ–π 4 –∫–≥ –¥–≤–∏–∂–µ—Ç—Å—è —Å–æ —Å–∫–æ—Ä–æ—Å—Ç—å—é 10 –º/—Å. –ö–∞–∫–æ–≤–∞ –µ–≥–æ –∫–∏–Ω–µ—Ç–∏—á–µ—Å–∫–∞—è —ç–Ω–µ—Ä–≥–∏—è (–≤ –î–∂)?" }, back: { content: "200" } },
                          { front: { title: "–ó–∞–¥–∞—á–∞: –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è", content: "–¢–µ–ª–æ –º–∞—Å—Å–æ–π 2 –∫–≥ –ø–æ–¥–Ω—è—Ç–æ –Ω–∞ –≤—ã—Å–æ—Ç—É 5 –º. –ö–∞–∫–æ–≤–∞ –µ–≥–æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è (g=10 –º/—Å¬≤) (–≤ –î–∂)?" }, back: { content: "100" } },
                          { front: { title: "–ó–∞–¥–∞—á–∞: –ó–∞–∫–æ–Ω –û–º–∞", content: "–ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ –Ω–∞ —Ä–µ–∑–∏—Å—Ç–æ—Ä–µ 12 –í, —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ 3 –û–º. –ö–∞–∫–æ–≤–∞ —Å–∏–ª–∞ —Ç–æ–∫–∞ (–≤ –ê)?" }, back: { content: "4" } },
                          { front: { title: "–ó–∞–¥–∞—á–∞: –ú–æ—â–Ω–æ—Å—Ç—å —Ç–æ–∫–∞", content: "–°–∏–ª–∞ —Ç–æ–∫–∞ –≤ –ª–∞–º–ø–µ 0.5 –ê, –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ 220 –í. –ö–∞–∫–æ–≤–∞ –º–æ—â–Ω–æ—Å—Ç—å –ª–∞–º–ø—ã (–≤ –í—Ç)?" }, back: { content: "110" } },
                          { front: { title: "–ó–∞–¥–∞—á–∞: –ò–º–ø—É–ª—å—Å", content: "–¢–µ–ª–æ –º–∞—Å—Å–æ–π 0.5 –∫–≥ –¥–≤–∏–∂–µ—Ç—Å—è —Å–æ —Å–∫–æ—Ä–æ—Å—Ç—å—é 8 –º/—Å. –ß–µ–º—É —Ä–∞–≤–µ–Ω –∏–º–ø—É–ª—å—Å —Ç–µ–ª–∞ (–≤ –∫–≥¬∑–º/—Å)?" }, back: { content: "4" } },
                          { front: { title: "–ó–∞–¥–∞—á–∞: –¢–µ–ø–ª–æ—Ç–∞ (–ù–∞–≥—Ä–µ–≤–∞–Ω–∏–µ)", content: "–£–¥–µ–ª—å–Ω–∞—è —Ç–µ–ø–ª–æ–µ–º–∫–æ—Å—Ç—å –≤–æ–¥—ã 4200 –î–∂/(–∫–≥¬∑¬∞C). –°–∫–æ–ª—å–∫–æ —Ç–µ–ø–ª–æ—Ç—ã (–≤ –∫–î–∂) –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã –Ω–∞–≥—Ä–µ—Ç—å 0.5 –∫–≥ –≤–æ–¥—ã –Ω–∞ 20 ¬∞C?" }, back: { content: "42" } },
                          { front: { title: "–ó–∞–¥–∞—á–∞: –ß–∞—Å—Ç–æ—Ç–∞", content: "–ú–∞—è—Ç–Ω–∏–∫ —Å–æ–≤–µ—Ä—à–∏–ª 50 –∫–æ–ª–µ–±–∞–Ω–∏–π –∑–∞ 10 —Å–µ–∫—É–Ω–¥. –ö–∞–∫–æ–≤–∞ —á–∞—Å—Ç–æ—Ç–∞ –∫–æ–ª–µ–±–∞–Ω–∏–π (–≤ –ì—Ü)?" }, back: { content: "5" } }
                     ]
                }
            }
        };
        let allDecks = {};

        // --- Global Variables (Added timer and perfection tracking) ---
        let customDecks = {};
        let currentDeckId = null;
        let currentDeckData = null;
        let currentDeckCards = [];
        let termsDeck = [];
        let problemsDeck = [];
        let originalTermsDeck = [];
        let originalProblemsDeck = [];
        let currentCardIndex = 0;
        let isFlipped = false;
        let isShuffled = false;
        let currentLanguage = 'ru';
        let currentMode = 'flashcard';
        let stats = { reviewed: 0, correct: 0, streak: 0, maxStreak: 0, badgesEarned: [] }; // Store earned badges {id, name, description}
        let earnedBadges = new Set(); // Store IDs of earned badges to prevent duplicates
        let viewedTermCardIndices = new Set();
        // Global total attempts/correct for overall stats display
        let totalAttempts = 0;
        let totalCorrect = 0; // Rename from stats.correct for clarity
        // Session-specific counters for perfection badge
        let quizAttemptsInSession = 0;
        let quizCorrectInSession = 0;
        let problemAttemptsInSession = 0;
        let problemCorrectInSession = 0;
        let termInputCounter = 0;
        let problemInputCounter = 0;
        let quizAnswered = false;
        // Timer variables
        let timerInterval = null;
        let timerStartTime = 0;
        let elapsedSeconds = 0;


        // --- DOM Elements (Added timer, achievements, deck display) ---
        const flashcardEl = document.getElementById('flashcard');
        const front = flashcardEl?.querySelector('.flashcard-front');
        const back = flashcardEl?.querySelector('.flashcard-back');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const flipBtn = document.getElementById('flipBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const progressBar = document.getElementById('progressBar');
        const timerDisplay = document.getElementById('timerDisplay'); // New Timer Element
        const chooseDeckBtn = document.getElementById('chooseDeckBtn');
        const deckModal = document.getElementById('deckModal');
        const closeDeckModalBtn = document.getElementById('closeDeckModal');
        const deckList = document.getElementById('deckList');
        const themeToggle = document.getElementById('themeToggle');
        const languageToggle = document.getElementById('languageToggle');
        const languageMenu = document.getElementById('languageMenu');
        const modeCards = document.querySelectorAll('.mode-card');
        const flashcardModeCard = document.getElementById('flashcardModeCard');
        const quizModeCard = document.getElementById('quizModeCard');
        const problemsModeCard = document.getElementById('problemsModeCard');
        const quizOptionsContainer = document.getElementById('quizOptions');
        const problemSolverContainer = document.getElementById('problemSolverContainer');
        const problemAnswerInput = document.getElementById('problemAnswerInput');
        const submitProblemAnswerBtn = document.getElementById('submitProblemAnswer');
        const answerFeedback = document.getElementById('answerFeedback');
        const cardsReviewedStat = document.getElementById('cardsReviewed');
        const correctAnswersStat = document.getElementById('correctAnswers'); // Will show totalCorrect
        const totalAttemptsStat = document.getElementById('totalAttempts'); // Will show totalAttempts
        const accuracyStat = document.getElementById('accuracy');
        const streakCountStat = document.getElementById('streakCount');
        const resetStatsBtn = document.getElementById('resetStatsBtn');
        const badgeNotification = document.getElementById('badgeNotification');
        const badgeDescription = badgeNotification?.querySelector('p#badgeDescription');
        const createDeckBtn = document.getElementById('createDeckBtn');
        const createDeckModal = document.getElementById('createDeckModal');
        const closeCreateDeckModalBtn = document.getElementById('closeCreateDeckModal');
        const createDeckForm = document.getElementById('createDeckForm');
        const deckTitleInput = document.getElementById('deckTitleInput');
        const deckDescInput = document.getElementById('deckDescInput');
        const deckTypeInput = document.getElementById('deckTypeInput');
        const termsSection = document.getElementById('termsSection');
        const problemsSection = document.getElementById('problemsSection');
        const termsInputContainer = document.getElementById('termsInputContainer');
        const problemsInputContainer = document.getElementById('problemsInputContainer');
        const addAnotherTermBtn = document.getElementById('addAnotherTermBtn');
        const addAnotherProblemBtn = document.getElementById('addAnotherProblemBtn');
        const createDeckModalTitle = document.getElementById('createDeckModalTitle');
        const achievementsBtn = document.getElementById('achievementsBtn'); // New Achievements Button
        const achievementsModal = document.getElementById('achievementsModal'); // New Achievements Modal
        const closeAchievementsModalBtn = document.getElementById('closeAchievementsModal'); // New Close Button
        const achievementsList = document.getElementById('achievementsList'); // New List Element
        const currentDeckDisplay = document.getElementById('currentDeckDisplay'); // New Deck Display Element
        const currentDeckLabelSpan = currentDeckDisplay?.querySelector('span');


        // --- Functions ---

        // renderMathJax, load/save custom decks, combine decks (Same as previous)
        function renderMathJax() {
            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                try {
                     // Ensure elements exist before passing to MathJax
                    const elementsToTypeset = [flashcardEl, quizOptionsContainer].filter(el => el && document.body.contains(el));
                    if (elementsToTypeset.length > 0) {
                        MathJax.typesetPromise(elementsToTypeset).catch(err => console.error("–û—à–∏–±–∫–∞ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ MathJax –≤–Ω—É—Ç—Ä–∏ promise:", err));
                    }
                } catch(e) {
                    console.error("–û—à–∏–±–∫–∞ –≤—ã–∑–æ–≤–∞ MathJax.typesetPromise:", e);
                }
            } else {
                 // console.log("MathJax –Ω–µ –≥–æ—Ç–æ–≤ –¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞.");
            }
        }

        // loadCustomDecksFromLocalStorage, saveCustomDecksToLocalStorage, combineAllDecks (Same as previous)
         function loadCustomDecksFromLocalStorage() {
            const storedDecks = localStorage.getItem('customFlashcardDecks');
            if (storedDecks) {
                try {
                    customDecks = JSON.parse(storedDecks);
                    // console.log("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∫–æ–ª–æ–¥—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã:", customDecks);
                    return customDecks;
                } catch (e) {
                    console.error("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –∫–æ–ª–æ–¥:", e);
                    customDecks = {};
                    localStorage.removeItem('customFlashcardDecks');
                    return {};
                }
            }
            // console.log("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∫–æ–ª–æ–¥—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.");
            customDecks = {};
            return {};
        }

        function saveCustomDecksToLocalStorage() {
            try {
                localStorage.setItem('customFlashcardDecks', JSON.stringify(customDecks));
                // console.log("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∫–æ–ª–æ–¥—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã:", customDecks);
            } catch (e) {
                console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –∫–æ–ª–æ–¥:", e);
                alert("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–ª–æ–¥—ã. –í–æ–∑–º–æ–∂–Ω–æ, —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–æ.");
            }
        }

        function combineAllDecks() {
            const loadedCustomDecks = loadCustomDecksFromLocalStorage();
            const clonedPredefined = JSON.parse(JSON.stringify(predefinedDecksMultiLang));
            allDecks = { ...clonedPredefined, ...loadedCustomDecks };
            // console.log("–í—Å–µ –∫–æ–ª–æ–¥—ã –æ–±—ä–µ–¥–∏–Ω–µ–Ω—ã:", allDecks);
        }

        // updateLanguage (Ensure new keys are handled)
        function updateLanguage(lang) {
            if (!languages[lang]) lang = 'ru';
            currentLanguage = lang;
            localStorage.setItem('flashcardLang', lang);
            document.documentElement.lang = lang;
            document.title = languages[lang]?.['html-title'] || "Flashcards";

            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.getAttribute('data-lang-key');
                const translation = languages[lang]?.[key];
                if (translation !== undefined) {
                     if ((el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') && el.placeholder !== undefined) el.placeholder = translation;
                     else if (el.tagName === 'OPTION') el.textContent = translation;
                     else if (el.title && (el.id === 'languageToggle' || el.id === 'themeToggle' || el.id === 'resetStatsBtn' || el.classList.contains('delete-term-btn') || el.classList.contains('delete-problem-btn') || el.classList.contains('delete-deck-btn') || el.classList.contains('close-modal'))) { el.title = translation; if (el.ariaLabel) el.ariaLabel = translation;}
                     else if (el.tagName === 'BUTTON' && el.querySelector('span[data-lang-key]')) { const span = el.querySelector('span[data-lang-key]'); if(span && span.dataset.langKey === key) span.textContent = translation; }
                     else if (el.id === 'currentDeckDisplay' && currentDeckLabelSpan) { el.firstChild.textContent = translation + ' '; } // Handle deck display label
                     else el.textContent = translation;
                }
            });

            if (shuffleBtn) shuffleBtn.textContent = languages[currentLanguage]?.[isShuffled ? 'original-order' : 'shuffle'] || (isShuffled ? '–ü–æ –ø–æ—Ä—è–¥–∫—É' : '–ü–µ—Ä–µ–º–µ—à–∞—Ç—å');
            if (currentDeckId && currentDeckLabelSpan) currentDeckLabelSpan.textContent = currentDeckData?.title || currentDeckId; // Update displayed deck name
            else if (currentDeckLabelSpan) currentDeckLabelSpan.textContent = ''; // Clear if no deck

            if (currentDeckId) { updateCard(); if (currentMode === 'quiz') generateQuizOptions(); }
            else showInitialMessage();

            if (deckModal?.style.display === 'flex') populateDeckList();
            if (createDeckModal?.style.display === 'flex') updateLanguageForElement(createDeckModal);
            if (achievementsModal?.style.display === 'flex') populateAchievementsList(); // Update achievements modal lang if open
        }


        // shuffleArray (Same as previous)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // updateCard (Reset timer on card change)
        function updateCard() {
            if (!flashcardEl || !front || !back) return;
            if (!currentDeckCards || currentDeckCards.length === 0) { updateButtonStates(true); return; }
            if (currentCardIndex >= currentDeckCards.length) currentCardIndex = 0;
            if (currentCardIndex < 0) currentCardIndex = 0;

            const card = currentDeckCards[currentCardIndex];
            if (!card || !card.front || !card.back) {
                console.error("–û—à–∏–±–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∫–∞—Ä—Ç–æ—á–∫–∏:", currentCardIndex, card);
                front.innerHTML = '<h2>–û—à–∏–±–∫–∞</h2><p>–î–∞–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã –Ω–µ–≤–µ—Ä–Ω—ã</p>';
                back.innerHTML = '';
                updateButtonStates(true);
                return;
            }

            // --- Stats Update (Reviewed Terms) ---
            if ((currentMode === 'flashcard' || currentMode === 'quiz')) {
                 const originalIndex = originalTermsDeck.findIndex(c => c === card);
                 if (originalIndex !== -1 && !viewedTermCardIndices.has(originalIndex)) {
                    viewedTermCardIndices.add(originalIndex);
                    stats.reviewed = viewedTermCardIndices.size;
                    if (cardsReviewedStat) cardsReviewedStat.textContent = stats.reviewed;
                    // console.log(`Reviewed term card (original index ${originalIndex}). Total reviewed: ${stats.reviewed}`);
                 }
             }

            flashcardEl.classList.remove('flipped'); isFlipped = false;
            flashcardEl.classList.remove('card-animation'); void flashcardEl.offsetWidth; flashcardEl.classList.add('card-animation');
            front.innerHTML = ''; back.innerHTML = '';

            const isProblemMode = currentMode === 'problems';
            const isQuizMode = currentMode === 'quiz';

            // --- Populate Card Content ---
            if (isProblemMode) {
                front.innerHTML = `
                    <h2 class="flashcard-term-topic">${card.front.title || languages[currentLanguage]['problem-header'] || '–ó–∞–¥–∞—á–∞'}</h2>
                    <p class="flashcard-problem-text">${card.front.content || ''}</p>`;
                back.innerHTML = `
                    <div class="flashcard-back-section">
                        <strong>${languages[currentLanguage]['problem-answer-label'] || '–û—Ç–≤–µ—Ç:'}</strong>
                        <div class="flashcard-problem-answer">${card.back.content || '-'}</div>
                    </div>`;
            } else {
                front.innerHTML = `
                    <h2 class="flashcard-term-topic">${card.front.title || ''}</h2>
                    <p class="flashcard-term-prompt">${card.front.content || ''}</p>`;
                back.innerHTML = `
                    <div class="flashcard-back-section"><strong>${languages[currentLanguage]['card-back-formula-label'] || '–§–æ—Ä–º—É–ª–∞:'}</strong><div class="flashcard-back-content">${card.back.formula || '-'}</div></div>
                    <div class="flashcard-back-section"><strong>${languages[currentLanguage]['card-back-units-label'] || '–ï–¥. –∏–∑–º.:'}</strong><div class="flashcard-back-content">${card.back.units || '-'}</div></div>
                    <div class="flashcard-back-section"><strong>${languages[currentLanguage]['card-back-vars-label'] || '–û–±–æ–∑–Ω–∞—á–µ–Ω–∏—è:'}</strong><div class="flashcard-back-content">${card.back.vars || '-'}</div></div>
                    <div class="flashcard-back-section"><strong>${languages[currentLanguage]['card-back-content-label'] || '–û–±—ä—è—Å–Ω–µ–Ω–∏–µ:'}</strong><div class="flashcard-back-content">${card.back.content || '-'}</div></div>`;
            }

            renderMathJax();
            updateModeUI();
            hideAnswerFeedback();
            quizAnswered = false;
            updateProgressBar();
            updateButtonStates();

            // --- Timer Reset ---
            if (isQuizMode || isProblemMode) {
                resetTimer(); // Reset timer for the new card
                startTimer(); // Start it again
            }
        }

        // showInitialMessage (Clear deck display, stop timer)
        function showInitialMessage() {
             if (!flashcardEl || !front || !back) return;
             flashcardEl.classList.remove('flipped'); isFlipped = false;
             front.innerHTML = `<h2 class="flashcard-term-topic" data-lang-key="start-title">${languages[currentLanguage]['start-title']}</h2><p class="flashcard-term-prompt" data-lang-key="start-content">${languages[currentLanguage]['start-content']}</p>`;
             back.innerHTML = `<h2 data-lang-key="ready-title">${languages[currentLanguage]['ready-title']}</h2><p data-lang-key="ready-content">${languages[currentLanguage]['ready-content']}</p>`;
             if (quizOptionsContainer) quizOptionsContainer.style.display = 'none';
             if (problemSolverContainer) problemSolverContainer.style.display = 'none';
             hideAnswerFeedback();
             renderMathJax();
             updateProgressBar(true);
             updateButtonStates(true);
             if (currentDeckLabelSpan) currentDeckLabelSpan.textContent = ''; // Clear current deck display
             stopTimer(); // Ensure timer is stopped
             resetTimerDisplay(); // Reset display
        }

        // updateProgressBar, updateButtonStates, updateModesAvailability (Same as previous)
        function updateProgressBar(reset = false) {
            if (!progressBar) return;
            if (reset || !currentDeckCards || currentDeckCards.length === 0) {
                progressBar.style.width = '0%';
            } else {
                const progress = ((currentCardIndex + 1) / currentDeckCards.length) * 100;
                progressBar.style.width = `${progress}%`;
            }
        }

        function updateButtonStates(reset = false) {
            const noCardsLoaded = !currentDeckCards || currentDeckCards.length === 0;
            if (prevBtn) prevBtn.disabled = reset || noCardsLoaded || currentCardIndex === 0;
            if (nextBtn) nextBtn.disabled = reset || noCardsLoaded;
            if (flipBtn) flipBtn.disabled = reset || noCardsLoaded || currentMode !== 'flashcard';
            if (shuffleBtn) {
                shuffleBtn.disabled = reset || noCardsLoaded;
                shuffleBtn.textContent = languages[currentLanguage]?.[isShuffled ? 'original-order' : 'shuffle'] || (isShuffled ? '–ü–æ –ø–æ—Ä—è–¥–∫—É' : '–ü–µ—Ä–µ–º–µ—à–∞—Ç—å');
            }
        }


        // --- MODIFIED: updateModesAvailability ---
        function updateModesAvailability(hasTerms, hasProblems) {
             // console.log(`Updating modes availability: hasTerms=${hasTerms}, hasProblems=${hasProblems}`);
            if (!flashcardModeCard || !quizModeCard || !problemsModeCard) return; // Ensure elements exist

            // Toggle disabled class based on availability
            flashcardModeCard.classList.toggle('disabled', !hasTerms);
            quizModeCard.classList.toggle('disabled', !hasTerms);
            problemsModeCard.classList.toggle('disabled', !hasProblems);

            // Check if the *currently selected* mode card is now disabled
            const currentModeCard = document.querySelector(`.mode-card[data-mode="${currentMode}"]`);
            if (currentModeCard && currentModeCard.classList.contains('disabled')) {
                console.warn(`Current mode '${currentMode}' is now disabled.`);
                // Try switching to an available mode
                if (hasTerms) {
                     console.log("Switching to available 'flashcard' mode.");
                     switchMode('flashcard'); // Prioritize flashcard if terms available
                 } else if (hasProblems) {
                     console.log("Switching to available 'problems' mode.");
                     switchMode('problems');
                 } else {
                     // --- No modes available ---
                     console.warn("No modes available after update.");
                     // Do NOT call showInitialMessage here - let the calling function handle it
                     // Just ensure visual state reflects disabled modes
                     modeCards.forEach(card => card.classList.add('disabled'));
                 }
            } else if (currentModeCard) {
                // Ensure the current mode card remains visually active if it's still enabled
                modeCards.forEach(card => card.classList.remove('active'));
                currentModeCard.classList.add('active');
            }
        }

        // flipCard, nextCard, prevCard, toggleShuffle (Same as previous, nextCard triggers perfection check)
        function flipCard() {
            if (currentMode !== 'flashcard' || !currentDeckCards?.length || !flashcardEl) return;
            flashcardEl.classList.toggle('flipped');
            isFlipped = !isFlipped;
        }
         function nextCard() {
             if (!currentDeckCards?.length) return;
             if (currentCardIndex < currentDeckCards.length - 1) {
                 currentCardIndex++;
                 updateCard();
             } else {
                 // Reached end of the current set
                 checkPerfectionBadge(currentMode); // Check perfection before wrapping/stopping
                 checkBadgeCompletion(); // Check standard completion badge
                 console.log(`Reached end of ${currentMode} cards.`);
                 currentCardIndex = 0; // Wrap around
                 updateCard();
             }
         }
         function prevCard() {
            if (currentCardIndex > 0) {
                currentCardIndex--;
                updateCard();
            }
        }

       function toggleShuffle() {
             let deckToShuffle = (currentMode === 'problems') ? problemsDeck : termsDeck;
             let originalDeck = (currentMode === 'problems') ? originalProblemsDeck : originalTermsDeck;

            if (!deckToShuffle || deckToShuffle.length < 2) return;

            isShuffled = !isShuffled;
            if (isShuffled) {
                currentDeckCards = shuffleArray([...deckToShuffle]);
                // console.log(`–ö–æ–ª–æ–¥–∞ (${currentMode}) –ø–µ—Ä–µ–º–µ—à–∞–Ω–∞.`);
            } else {
                currentDeckCards = [...originalDeck];
                // console.log(`–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏—Å—Ö–æ–¥–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ (${currentMode}).`);
            }
            currentCardIndex = 0;
            updateCard();
        }

        // --- Timer Functions ---
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = (seconds % 60).toString().padStart(2, '0');
            return `${mins}:${secs}`;
        }

        function updateTimerDisplay() {
            if (timerDisplay) {
                timerDisplay.textContent = formatTime(elapsedSeconds);
            }
        }

         function resetTimerDisplay() {
             if (timerDisplay) {
                 timerDisplay.textContent = formatTime(0);
                 timerDisplay.classList.remove('visible');
             }
         }

        function startTimer() {
            stopTimer(); // Clear any existing timer first
            if (timerDisplay) timerDisplay.classList.add('visible');
            timerStartTime = Date.now();
            elapsedSeconds = 0; // Reset elapsed time for the new card/start
            updateTimerDisplay(); // Show 00:00 immediately

            timerInterval = setInterval(() => {
                elapsedSeconds = Math.floor((Date.now() - timerStartTime) / 1000);
                updateTimerDisplay();
            }, 1000);
             // console.log("Timer started");
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                 // console.log("Timer stopped");
            }
            if (timerDisplay) timerDisplay.classList.remove('visible'); // Hide timer when stopped
        }

        function resetTimer() {
            stopTimer();
            elapsedSeconds = 0;
            resetTimerDisplay();
             // console.log("Timer reset");
        }


        // --- MODIFIED: loadDeck (Check perfection, reset session counters, update deck display, handle timer) ---
        function loadDeck(deckId) {
             // --- Check Perfection Before Loading New Deck ---
             checkPerfectionBadge(currentMode); // Check based on the mode we are *leaving*

             const rawDeckData = allDecks[deckId];
             if (!rawDeckData) { /* ... error handling ... */ currentDeckId = null; showInitialMessage(); updateModesAvailability(false, false); return; }

             currentDeckData = rawDeckData[currentLanguage] || rawDeckData['ru'] || Object.values(rawDeckData).find(d => typeof d === 'object' && (d.cards || d.termsCards || d.problemsCards)) || rawDeckData;
             if (!currentDeckData || typeof currentDeckData !== 'object') { /* ... error handling ... */ currentDeckId = null; showInitialMessage(); updateModesAvailability(false, false); return; }

             currentDeckId = deckId;
             localStorage.setItem('lastDeckId', deckId);
             const deckType = currentDeckData.deckType || 'terms';
             const deckTitle = currentDeckData.title || deckId;

             // Reset state
             termsDeck = []; problemsDeck = []; originalTermsDeck = []; originalProblemsDeck = [];
             currentCardIndex = 0; isShuffled = false;
             viewedTermCardIndices.clear();

             // --- Reset Global and Session Stats ---
             resetStats(); // Reset includes totalCorrect, totalAttempts, streak etc.
             // Explicitly reset session counters for perfection tracking
             quizAttemptsInSession = 0; quizCorrectInSession = 0;
             problemAttemptsInSession = 0; problemCorrectInSession = 0;

             // Populate decks
             if (deckType === 'combined') { termsDeck = currentDeckData.termsCards || []; problemsDeck = currentDeckData.problemsCards || []; }
             else if (deckType === 'terms') { termsDeck = currentDeckData.cards || []; }
             else if (deckType === 'problems') { problemsDeck = currentDeckData.cards || []; }
             originalTermsDeck = [...termsDeck]; originalProblemsDeck = [...problemsDeck];

             const hasTerms = termsDeck.length > 0;
             const hasProblems = problemsDeck.length > 0;

             // --- Determine Initial Mode & Stop Timer ---
             stopTimer(); // Stop timer from previous deck
             resetTimerDisplay(); // Reset timer display
             let initialMode = 'flashcard'; // Default start mode

             if (hasTerms) { initialMode = 'flashcard'; currentDeckCards = [...termsDeck]; }
             else if (hasProblems) { initialMode = 'problems'; currentDeckCards = [...problemsDeck]; }
             else { initialMode = 'flashcard'; currentDeckCards = []; }

             // Set the mode *before* potentially starting the timer
             currentMode = initialMode;

             // Update Deck Display
             if (currentDeckLabelSpan) currentDeckLabelSpan.textContent = deckTitle;
             else if (currentDeckDisplay) currentDeckDisplay.firstChild.textContent = (languages[currentLanguage]['current-deck-label'] || '–¢–µ–∫—É—â–∞—è –∫–æ–ª–æ–¥–∞:') + ' '; // Ensure label text exists

             // --- Update UI & Start Timer if applicable ---
             if (currentDeckCards.length > 0) {
                 updateCard(); // Update display first
             } else {
                 showInitialMessage(); // Show initial message if deck is effectively empty
             }
             updateModesAvailability(hasTerms, hasProblems); // THEN update mode button states

             // Start timer ONLY if the initial mode is quiz or problems
             if (currentMode === 'quiz' || currentMode === 'problems') {
                 startTimer();
             }
         }


        // --- MODIFIED: updateStats (Use totalCorrect/totalAttempts) ---
        function updateStats(type, mode) { // mode needed to update session counters
            let updateAccuracyDisplay = false;

            // Update session counters based on mode
             if (mode === 'quiz') {
                 quizAttemptsInSession++;
                 if (type === 'correct') quizCorrectInSession++;
             } else if (mode === 'problems') {
                 problemAttemptsInSession++;
                 if (type === 'correct') problemCorrectInSession++;
             }

             // Update global counters
            if (type === 'correct') {
                totalCorrect++;
                stats.streak++;
                stats.maxStreak = Math.max(stats.maxStreak, stats.streak);
                totalAttempts++;
                updateAccuracyDisplay = true;
                checkBadges(); // Check for streak badges
            } else if (type === 'incorrect') {
                stats.streak = 0;
                totalAttempts++;
                updateAccuracyDisplay = true;
            }
            // 'reviewed' stat is updated separately in updateCard

            // Update display elements
            if (correctAnswersStat) correctAnswersStat.textContent = totalCorrect;
            if (streakCountStat) streakCountStat.textContent = stats.streak;
            if (totalAttemptsStat) totalAttemptsStat.textContent = totalAttempts;
            if (updateAccuracyDisplay && accuracyStat) {
                const accuracyValue = totalAttempts > 0 ? ((totalCorrect / totalAttempts) * 100).toFixed(0) : 0;
                accuracyStat.textContent = `${accuracyValue}%`;
            }
        }

        // populateDeckList, handleDeleteDeck, toggleTheme, initializeTheme, initializeLanguage (Same as previous)
        function populateDeckList() {
            if (!deckList) return;
            deckList.innerHTML = '';
            // console.log("–ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∫–æ–ª–æ–¥ –∏–∑:", allDecks);
            const deckEntries = Object.entries(allDecks);
             deckEntries.sort(([idA, deckA], [idB, deckB]) => {
                 const isAPredefined = predefinedDecksMultiLang.hasOwnProperty(idA);
                 const isBPredefined = predefinedDecksMultiLang.hasOwnProperty(idB);
                 if (isAPredefined && !isBPredefined) return -1;
                 if (!isAPredefined && isBPredefined) return 1;
                 const titleA = (deckA[currentLanguage]?.title || deckA['ru']?.title || deckA.title || idA).toLowerCase();
                 const titleB = (deckB[currentLanguage]?.title || deckB['ru']?.title || deckB.title || idB).toLowerCase();
                 return titleA.localeCompare(titleB);
             });

            deckEntries.forEach(([deckId, deckData]) => {
                const langContent = deckData[currentLanguage] || deckData['ru'] || Object.values(deckData).find(d => typeof d === 'object' && (d.cards || d.termsCards || d.problemsCards)) || deckData;
                if (!langContent || typeof langContent !== 'object') {
                    console.warn(`Skipping deck ${deckId}: Invalid data structure.`);
                    return;
                }
                const title = langContent.title || deckId;
                const description = langContent.description || "";
                const deckType = langContent.deckType || 'terms';
                const isCustom = customDecks.hasOwnProperty(deckId);
                let cardCount = 0;
                if (deckType === 'combined') {
                    cardCount = (langContent.termsCards?.length || 0) + (langContent.problemsCards?.length || 0);
                } else if (deckType === 'terms') {
                    cardCount = langContent.cards?.length || langContent.termsCards?.length || 0;
                } else if (deckType === 'problems') {
                    cardCount = langContent.cards?.length || langContent.problemsCards?.length || 0;
                }
                let typeKey = 'deck-type-terms';
                if (deckType === 'problems') typeKey = 'deck-type-problems';
                else if (deckType === 'combined') typeKey = 'deck-type-combined'; // Corrected
                const typeText = languages[currentLanguage]?.[typeKey] || deckType;

                const li = document.createElement('li');
                li.classList.add('deck-item');
                li.dataset.deckId = deckId;
                const deleteBtnTitle = `${languages[currentLanguage]?.['confirm-delete'] || '–£–¥–∞–ª–∏—Ç—å –∫–æ–ª–æ–¥—É'} ${title}`;
                li.innerHTML = `
                    <h3 class="deck-title">${title} <span style="font-size:0.8em; color: #888;">(${typeText})</span></h3>
                    <p class="deck-info">${description}</p>
                    <p class="deck-info">${cardCount} –∫–∞—Ä—Ç(—ã)</p>
                    ${isCustom ? `<button class="delete-deck-btn" data-deck-id="${deckId}" aria-label="${deleteBtnTitle}" title="${deleteBtnTitle}">üóëÔ∏è</button>` : ''}
                `;
                li.addEventListener('click', (e) => {
                    if (e.target.classList.contains('delete-deck-btn')) return;
                    loadDeck(deckId);
                    if (deckModal) deckModal.style.display = 'none';
                });
                const deleteBtn = li.querySelector('.delete-deck-btn');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handleDeleteDeck(deckId);
                    });
                }
                deckList.appendChild(li);
            });
            if (deckEntries.length === 0) {
                deckList.innerHTML = `<li data-lang-key="no-decks-available">${languages[currentLanguage]?.['no-decks-available'] || '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–ª–æ–¥.'}</li>`;
            }
        }

        function handleDeleteDeck(deckId) {
            if (!customDecks[deckId]) return;
            const deckTitleToDelete = (customDecks[deckId][currentLanguage]?.title || customDecks[deckId]['ru']?.title || customDecks[deckId].title || deckId);
            if (confirm(`${languages[currentLanguage]?.['confirm-delete'] || '–£–¥–∞–ª–∏—Ç—å –∫–æ–ª–æ–¥—É'} "${deckTitleToDelete}"?`)) {
                delete customDecks[deckId];
                delete allDecks[deckId];
                saveCustomDecksToLocalStorage();
                populateDeckList();
                if (currentDeckId === deckId) {
                    currentDeckId = null;
                    currentDeckData = null;
                    currentDeckCards = [];
                    termsDeck = []; problemsDeck = [];
                    originalTermsDeck = []; originalProblemsDeck = [];
                    const firstDeckId = Object.keys(allDecks)[0];
                    if (firstDeckId) {
                        loadDeck(firstDeckId);
                    } else {
                        showInitialMessage();
                         updateModesAvailability(false, false); // Ensure modes are disabled
                    }
                }
                // console.log(`–ö–æ–ª–æ–¥–∞ "${deckId}" —É–¥–∞–ª–µ–Ω–∞.`);
            }
        }

        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const isDarkMode = document.body.classList.contains('dark-mode');
            if (themeToggle) themeToggle.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô';
            localStorage.setItem('flashcardTheme', isDarkMode ? 'dark' : 'light');
        }

        function initializeTheme() {
            const savedTheme = localStorage.getItem('flashcardTheme');
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
                if (themeToggle) themeToggle.textContent = '‚òÄÔ∏è';
            } else {
                document.body.classList.remove('dark-mode');
                if (themeToggle) themeToggle.textContent = 'üåô';
            }
        }

        function initializeLanguage() {
            const savedLang = localStorage.getItem('flashcardLang') || navigator.language.split('-')[0] || 'ru';
            updateLanguage(languages[savedLang] ? savedLang : 'ru');
        }

        // --- MODIFIED: initializeDecks ---
        function initializeDecks() {
            combineAllDecks();
            const lastDeckId = localStorage.getItem('lastDeckId');
            let deckToLoad = null;

            if (lastDeckId && allDecks[lastDeckId]) {
                deckToLoad = lastDeckId;
            } else {
                 // Find the first deck ID from the potentially sorted list
                const firstDeckId = Object.keys(allDecks)[0];
                if(firstDeckId) {
                    deckToLoad = firstDeckId;
                }
            }

            if (deckToLoad) {
                 // console.log("Initializing with deck:", deckToLoad);
                loadDeck(deckToLoad);
            } else {
                console.warn("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–ª–æ–¥ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏.");
                showInitialMessage(); // Show start message if no decks exist
                 updateModesAvailability(false, false); // Ensure modes are disabled
            }
        }

        // updateModeUI, switchMode, generateQuizOptions, checkQuizAnswer, checkProblemAnswer (Same logic as previous)
         function updateModeUI() {
            hideAnswerFeedback();
            if (problemAnswerInput) problemAnswerInput.value = '';
            quizAnswered = false;

            const isQuiz = currentMode === 'quiz';
            const isProblems = currentMode === 'problems';
            const isFlashcard = currentMode === 'flashcard';

            if (quizOptionsContainer) quizOptionsContainer.style.display = isQuiz ? 'flex' : 'none';
            if (problemSolverContainer) problemSolverContainer.style.display = isProblems ? 'block' : 'none';
            if (flipBtn) flipBtn.style.display = isFlashcard ? 'inline-flex' : 'none';

            if (isQuiz) generateQuizOptions();
        }


        // --- MODIFIED: switchMode (Check perfection, reset session counters, handle timer) ---
        function switchMode(newMode) {
             const targetCard = document.querySelector(`.mode-card[data-mode="${newMode}"]`);
             if (!targetCard || targetCard.classList.contains('disabled') || currentMode === newMode) return;

             const oldMode = currentMode;
             console.log(`–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ —Å ${oldMode} –Ω–∞ ${newMode}`);

             // --- Check Perfection Badge for the mode we are LEAVING ---
             checkPerfectionBadge(oldMode);

             currentMode = newMode;

             // Update active state visual
             modeCards.forEach(card => card.classList.remove('active'));
             targetCard.classList.add('active');

             // Reset session counters when switching *to* a quiz/problem mode
             if (newMode === 'quiz') { quizAttemptsInSession = 0; quizCorrectInSession = 0; }
             if (newMode === 'problems') { problemAttemptsInSession = 0; problemCorrectInSession = 0; }

             // Switch the active card deck
             isShuffled = false;
             if (newMode === 'problems') { currentDeckCards = [...originalProblemsDeck]; }
             else { currentDeckCards = [...originalTermsDeck]; } // flashcard or quiz

             currentCardIndex = 0;

              // --- Handle Timer ---
              if (newMode === 'quiz' || newMode === 'problems') {
                  resetTimer(); // Reset timer before starting
                  startTimer();
              } else {
                  stopTimer(); // Stop timer if switching to flashcards
                  resetTimerDisplay();
              }
              // --- End Handle Timer ---

             updateCard(); // Update the display for the new mode and card
         }


        // generateQuizOptions (Same as previous)
        function generateQuizOptions() {
            if (!quizOptionsContainer) return;
            quizOptionsContainer.innerHTML = '';
             const deckSource = originalTermsDeck;
             const currentTermCard = currentDeckCards[currentCardIndex];
            if (!deckSource || deckSource.length === 0 || !currentTermCard?.back?.content) {
                quizOptionsContainer.innerHTML = `<p>${languages[currentLanguage]?.['no-options'] || '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.'}</p>`;
                return;
            }
            const correctAnswer = currentTermCard.back.content;
            let options = [correctAnswer];
            let attempts = 0;
            const maxOptions = Math.min(4, deckSource.length);
            while (options.length < maxOptions && attempts < deckSource.length * 3) {
                const randomIndex = Math.floor(Math.random() * deckSource.length);
                const potentialCard = deckSource[randomIndex];
                const potentialAnswer = potentialCard?.back?.content;
                if (potentialAnswer && potentialAnswer !== correctAnswer && !options.includes(potentialAnswer)) {
                    options.push(potentialAnswer);
                }
                attempts++;
            }
            shuffleArray(options);
            options.forEach(option => {
                const button = document.createElement('button');
                button.classList.add('quiz-option', 'button-style');
                 button.textContent = option;
                button.onclick = () => checkQuizAnswer(option === correctAnswer, button);
                quizOptionsContainer.appendChild(button);
            });
             renderMathJax();
        }

        // --- MODIFIED: checkQuizAnswer (Update session counters) ---
        function checkQuizAnswer(isCorrect, selectedButton) {
            if (quizAnswered || !currentDeckCards?.length) return;
            quizAnswered = true;
            showAnswerFeedback(isCorrect);
            updateStats(isCorrect ? 'correct' : 'incorrect', 'quiz'); // Pass 'quiz' mode

            const correctAnswerText = currentDeckCards[currentCardIndex].back.content;
            quizOptionsContainer.querySelectorAll('.quiz-option').forEach(btn => {
                btn.disabled = true;
                const isBtnCorrectAnswer = (btn.textContent === correctAnswerText);
                if (btn === selectedButton) btn.classList.add(isCorrect ? 'correct' : 'incorrect');
                else if (isBtnCorrectAnswer && !isCorrect) btn.classList.add('correct');
            });
        }

        // --- MODIFIED: checkProblemAnswer (Update session counters) ---
        function checkProblemAnswer() {
            if (currentMode !== 'problems' || !currentDeckCards?.length || !currentDeckCards[currentCardIndex]?.back?.content || !problemAnswerInput) return;
            const userAnswerStr = problemAnswerInput.value.trim();
            const correctAnswerStr = String(currentDeckCards[currentCardIndex].back.content).trim();
            if (userAnswerStr === "") { showAnswerFeedback(false, correctAnswerStr); updateStats('incorrect', 'problems'); return; } // Pass 'problems' mode
             const userNum = parseFloat(userAnswerStr.replace(',', '.'));
             const correctNum = parseFloat(correctAnswerStr.replace(',', '.'));
             let isCorrect = false;
             if (!isNaN(userNum) && !isNaN(correctNum)) isCorrect = Math.abs(userNum - correctNum) < 0.001;
             else isCorrect = userAnswerStr.toLowerCase() === correctAnswerStr.toLowerCase();

            showAnswerFeedback(isCorrect, isCorrect ? null : correctAnswerStr);
            updateStats(isCorrect ? 'correct' : 'incorrect', 'problems'); // Pass 'problems' mode
        }


        // showAnswerFeedback, hideAnswerFeedback (Same as previous)
        function showAnswerFeedback(isCorrect, correctAnswerText = null) {
            if (!answerFeedback) return;
            answerFeedback.style.display = 'block';
            let feedbackTextKey = isCorrect ? 'correct-feedback' : 'incorrect-feedback';
            let feedbackText = languages[currentLanguage]?.[feedbackTextKey] || (isCorrect ? 'Correct! ‚úì' : 'Incorrect ‚úó');
            if (!isCorrect && correctAnswerText != null) {
                 feedbackText += ` <span class="correct-answer-text">"${correctAnswerText}"</span>`;
            }
            answerFeedback.innerHTML = feedbackText;
            answerFeedback.className = 'answer-feedback';
            answerFeedback.classList.add(isCorrect ? 'correct' : 'incorrect');
        }

        function hideAnswerFeedback() {
            if (answerFeedback) answerFeedback.style.display = 'none';
        }

        // --- MODIFIED: resetStats (Reset totalCorrect/totalAttempts) ---
        function resetStats() {
             // Reset global stats object
             stats = { reviewed: 0, /* correct: 0, - removed */ streak: 0, maxStreak: 0, badgesEarned: stats.badgesEarned }; // Keep earned badges across resets? Or clear here? Let's keep them for now.
             // earnedBadges = new Set(); // Uncomment to clear badge IDs on reset
             viewedTermCardIndices.clear();

             // Reset displayed global counters
             totalAttempts = 0;
             totalCorrect = 0;

             // Update UI elements
             if (cardsReviewedStat) cardsReviewedStat.textContent = '0';
             if (correctAnswersStat) correctAnswersStat.textContent = '0'; // Display totalCorrect
             if (accuracyStat) accuracyStat.textContent = '0%';
             if (streakCountStat) streakCountStat.textContent = '0'; // Streak resets
             if (totalAttemptsStat) totalAttemptsStat.textContent = '0'; // Display totalAttempts

             console.log("–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ—Å—Å–∏–∏ —Å–±—Ä–æ—à–µ–Ω–∞ (–∫—Ä–æ–º–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π).");

             // Reset progress bar and card index only if a deck is loaded
             if (currentDeckId) {
                 currentCardIndex = 0;
                 isShuffled = false; // Ensure deck is unshuffled on reset
                 if (currentMode === 'problems') currentDeckCards = [...originalProblemsDeck];
                 else currentDeckCards = [...originalTermsDeck];
                 // updateCard(); // Avoid direct call if it causes issues, let flow handle it
                 updateProgressBar();
                 updateButtonStates();
                 hideAnswerFeedback();
             } else {
                 updateProgressBar(true);
                 updateButtonStates(true);
             }
        }

        // --- MODIFIED: checkBadges (Handles streak badges) ---
        function checkBadges() {
            // Only check streak badges here
            const streakBadges = [
                { id: 'streak-5', threshold: 5, key: 'streak-5-desc', titleKey: 'streak-title' },
                { id: 'streak-10', threshold: 10, key: 'streak-10-desc', titleKey: 'streak-title' }
            ];
            streakBadges.forEach(badge => {
                if (stats.streak >= badge.threshold && !earnedBadges.has(badge.id)) {
                    awardBadge(badge.id, badge.titleKey, badge.key);
                }
            });
        }

         // --- New Function: Check Perfection Badge ---
         function checkPerfectionBadge(modeToCheck) {
             if (!currentDeckId) return; // No deck loaded

             let attempts = 0;
             let correct = 0;
             let badgeId = '';
             let titleKey = '';
             let descKey = '';

             if (modeToCheck === 'quiz' && originalTermsDeck.length > 0) { // Check against original deck length
                 attempts = quizAttemptsInSession;
                 correct = quizCorrectInSession;
                 badgeId = `perfection-quiz-${currentDeckId}`;
                 titleKey = 'perfection-quiz-title';
                 descKey = 'perfection-quiz-desc';
                 console.log(`Checking Quiz Perfection: Attempts=${attempts}, Correct=${correct}, Required=${originalTermsDeck.length}`);
             } else if (modeToCheck === 'problems' && originalProblemsDeck.length > 0) {
                 attempts = problemAttemptsInSession;
                 correct = problemCorrectInSession;
                 badgeId = `perfection-problems-${currentDeckId}`;
                 titleKey = 'perfection-problems-title';
                 descKey = 'perfection-problems-desc';
                  console.log(`Checking Problems Perfection: Attempts=${attempts}, Correct=${correct}, Required=${originalProblemsDeck.length}`);
             }

             // Award if:
             // 1. We have a valid badge ID (meaning we were in quiz/problems mode)
             // 2. At least one attempt was made in that session
             // 3. Number of correct answers equals the total number of cards for that mode
             // 4. The badge hasn't been earned already
            if (badgeId && attempts > 0 && correct === attempts && !earnedBadges.has(badgeId)) {
                 const requiredCount = (modeToCheck === 'quiz') ? originalTermsDeck.length : originalProblemsDeck.length;
                 if (correct === requiredCount) { // Ensure all cards were attempted and correct
                    awardBadge(badgeId, titleKey, descKey);
                 } else {
                     console.log(`Perfection check failed: Not all cards attempted/correct (Correct: ${correct}, Required: ${requiredCount})`);
                 }
            } else if (badgeId && earnedBadges.has(badgeId)) {
                 console.log(`Badge ${badgeId} already earned.`);
            }
         }


        // checkBadgeCompletion (Handles deck completion - logic might need refinement based on term/problem split)
        function checkBadgeCompletion() {
             if (currentDeckCards?.length && currentCardIndex === currentDeckCards.length - 1) {
                 const badgeId = `completed-${currentDeckId}-${currentMode}`;
                 if (!earnedBadges.has(badgeId)) {
                     let deckTitle = currentDeckData?.title || currentDeckId;
                     const completionBadge = { id: badgeId, name: `${languages[currentLanguage]['deck-completed-title'] || 'Deck Completed!'}: ${deckTitle} (${currentMode})`, description: languages[currentLanguage]['deck-completed-desc'] || "You've studied all cards in this set." };
                     earnedBadges.add(badgeId);
                     stats.badgesEarned.push(completionBadge);
                     showBadgeNotification(completionBadge);
                 }
             }
        }

        // --- New Function to Award Badges ---
        function awardBadge(id, titleLangKey, descLangKey) {
            if (earnedBadges.has(id)) return; // Don't award twice

            const badgeData = {
                id: id,
                name: languages[currentLanguage][titleLangKey] || titleLangKey, // Fallback to key
                description: languages[currentLanguage][descLangKey] || descLangKey // Fallback to key
            };

            earnedBadges.add(id);
            stats.badgesEarned.push(badgeData); // Add to the list of earned badges
            showBadgeNotification(badgeData);
            saveEarnedBadges(); // Save achievements
            console.log(`–ó–Ω–∞—á–æ–∫ –ø–æ–ª—É—á–µ–Ω: ${id}`);
        }

        // --- New Function to Populate Achievements List ---
        function populateAchievementsList() {
            if (!achievementsList) return;
            achievementsList.innerHTML = ''; // Clear previous list
            loadEarnedBadges(); // Load latest earned badges

            if (stats.badgesEarned.length === 0) {
                achievementsList.innerHTML = `<li class="no-achievements" data-lang-key="no-achievements-yet">${languages[currentLanguage]['no-achievements-yet']}</li>`;
            } else {
                stats.badgesEarned.forEach(badge => {
                    const li = document.createElement('li');
                    li.classList.add('achievement-item');
                    li.innerHTML = `
                        <div class="achievement-icon">üèÜ</div>
                        <div class="achievement-details">
                            <h4>${badge.name}</h4>
                            <p>${badge.description}</p>
                        </div>
                    `;
                    achievementsList.appendChild(li);
                });
            }
        }

         // --- New Functions to Save/Load Achievements ---
         function saveEarnedBadges() {
             try {
                 // Save both the set of IDs and the full badge objects
                 localStorage.setItem('earnedBadgeIds', JSON.stringify(Array.from(earnedBadges)));
                 localStorage.setItem('earnedBadgesData', JSON.stringify(stats.badgesEarned));
             } catch (e) {
                 console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π:", e);
             }
         }

         function loadEarnedBadges() {
             try {
                 const storedIds = localStorage.getItem('earnedBadgeIds');
                 const storedData = localStorage.getItem('earnedBadgesData');
                 if (storedIds) {
                     earnedBadges = new Set(JSON.parse(storedIds));
                 } else {
                      earnedBadges = new Set();
                 }
                 if (storedData) {
                     stats.badgesEarned = JSON.parse(storedData);
                 } else {
                     stats.badgesEarned = [];
                 }
             } catch (e) {
                 console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π:", e);
                 earnedBadges = new Set();
                 stats.badgesEarned = [];
             }
         }


        // showBadgeNotification (Same as previous)
        function showBadgeNotification(badge) {
            if (!badgeNotification || !badgeDescription) return;
            const titleEl = badgeNotification.querySelector('h3');
            if(titleEl) titleEl.textContent = badge.name || (languages[currentLanguage]['achievement-unlocked'] || '–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ!');
            badgeDescription.textContent = badge.description || (languages[currentLanguage]['new-badge'] || '–í—ã –ø–æ–ª—É—á–∏–ª–∏ –∑–Ω–∞—á–æ–∫!');
            badgeNotification.style.display = 'block';
            setTimeout(() => { if (badgeNotification) badgeNotification.style.display = 'none'; }, 4000);
        }

        // updateLanguageForElement, renumberTermHeaders, renumberProblemHeaders, addTermInputFields, addProblemInputFields, toggleDeckTypeSections, createDeck (Same logic as previous)
         function updateLanguageForElement(element) {
            element?.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.getAttribute('data-lang-key');
                const translation = languages[currentLanguage]?.[key];
                if (translation !== undefined) {
                    if ((el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') && el.placeholder !== undefined) {
                        el.placeholder = translation;
                    }
                    if (el.tagName === 'LABEL' || el.tagName === 'BUTTON' || el.tagName === 'H3' || el.tagName === 'H4' || el.tagName === 'OPTION') {
                        const firstChild = el.firstChild;
                        if (firstChild && firstChild.nodeType === Node.TEXT_NODE) {
                            firstChild.textContent = translation;
                        } else if (el.childNodes.length > 0 && el.childNodes[0].nodeType === Node.TEXT_NODE) {
                             el.childNodes[0].textContent = translation; // Try updating first text node if icon present
                        } else {
                             el.textContent = translation;
                        }
                    }
                     if (el.title) el.title = translation;
                     if (el.ariaLabel) el.ariaLabel = translation;
                }
            });
        }

        function renumberTermHeaders() {
            const termInputDivs = termsInputContainer?.querySelectorAll('.term-inputs');
            termInputDivs?.forEach((div, index) => {
                const header = div.querySelector('.term-header');
                const deleteBtn = div.querySelector('.delete-term-btn');
                const newNumber = index + 1;
                const termText = languages[currentLanguage]?.['term-header'] || '–¢–µ—Ä–º–∏–Ω';
                if (header) header.textContent = `${termText} ${newNumber}`;
                if (deleteBtn) {
                    const deleteText = `${languages[currentLanguage]?.['delete-term'] || '–£–¥–∞–ª–∏—Ç—å –¢–µ—Ä–º–∏–Ω'} ${newNumber}`;
                    deleteBtn.setAttribute('aria-label', deleteText);
                    deleteBtn.setAttribute('title', deleteText);
                }
                div.querySelectorAll('input, textarea').forEach(input => {
                    const baseId = input.id.replace(/\d+$/, '');
                    input.id = `${baseId}${newNumber}`;
                    const label = div.querySelector(`label[for^="${baseId}"]`);
                    if (label) label.setAttribute('for', input.id);
                });
            });
            termInputCounter = termInputDivs?.length || 0;
        }

        function renumberProblemHeaders() {
            const problemInputDivs = problemsInputContainer?.querySelectorAll('.problem-inputs');
            problemInputDivs?.forEach((div, index) => {
                const header = div.querySelector('.problem-header');
                const deleteBtn = div.querySelector('.delete-problem-btn');
                const newNumber = index + 1;
                const problemText = languages[currentLanguage]?.['problem-header'] || '–ó–∞–¥–∞—á–∞';
                if (header) header.textContent = `${problemText} ${newNumber}`;
                if (deleteBtn) {
                     const deleteText = `${languages[currentLanguage]?.['delete-problem'] || '–£–¥–∞–ª–∏—Ç—å –ó–∞–¥–∞—á—É'} ${newNumber}`;
                    deleteBtn.setAttribute('aria-label', deleteText);
                    deleteBtn.setAttribute('title', deleteText);
                }
                 div.querySelectorAll('input, textarea').forEach(input => {
                     const baseId = input.id.replace(/\d+$/, '');
                     input.id = `${baseId}${newNumber}`;
                     const label = div.querySelector(`label[for^="${baseId}"]`);
                     if (label) label.setAttribute('for', input.id);
                 });
            });
            problemInputCounter = problemInputDivs?.length || 0;
        }

        function addTermInputFields() {
            if (!termsInputContainer) return;
            termInputCounter++;
            const div = document.createElement('div');
            div.classList.add('term-inputs');
            div.dataset.cardNumber = termInputCounter;
            const deleteText = `${languages[currentLanguage]?.['delete-term'] || '–£–¥–∞–ª–∏—Ç—å –¢–µ—Ä–º–∏–Ω'} ${termInputCounter}`;
            div.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <h4 class="term-header">${languages[currentLanguage]?.['term-header'] || '–¢–µ—Ä–º–∏–Ω'} ${termInputCounter}</h4>
                    <button type="button" class="delete-term-btn" aria-label="${deleteText}" title="${deleteText}">üóëÔ∏è</button>
                </div>
                <label for="termFrontTitle${termInputCounter}" data-lang-key="card-front-title-label">${languages[currentLanguage]?.['card-front-title-label'] || '–¢–µ–º–∞/–¢–µ—Ä–º–∏–Ω:'}</label>
                <input type="text" id="termFrontTitle${termInputCounter}" class="term-front-title">
                <label for="termFrontContent${termInputCounter}" data-lang-key="card-front-content-label">${languages[currentLanguage]?.['card-front-content-label'] || '–í–æ–ø—Ä–æ—Å/–û–ø–∏—Å–∞–Ω–∏–µ:'}</label>
                <textarea id="termFrontContent${termInputCounter}" class="term-front-content" required></textarea>
                <label for="termBackFormula${termInputCounter}" data-lang-key="card-back-formula-label">${languages[currentLanguage]?.['card-back-formula-label'] || '–§–æ—Ä–º—É–ª–∞:'}</label>
                <textarea id="termBackFormula${termInputCounter}" class="term-back-formula"></textarea>
                <label for="termBackUnits${termInputCounter}" data-lang-key="card-back-units-label">${languages[currentLanguage]?.['card-back-units-label'] || '–ï–¥. –∏–∑–º.:'}</label>
                <input type="text" id="termBackUnits${termInputCounter}" class="term-back-units">
                <label for="termBackVars${termInputCounter}" data-lang-key="card-back-vars-label">${languages[currentLanguage]?.['card-back-vars-label'] || '–û–±–æ–∑–Ω–∞—á–µ–Ω–∏—è:'}</label>
                <textarea id="termBackVars${termInputCounter}" class="term-back-vars"></textarea>
                <label for="termBackContent${termInputCounter}" data-lang-key="card-back-content-label">${languages[currentLanguage]?.['card-back-content-label'] || '–û–±—ä—è—Å–Ω–µ–Ω–∏–µ:'}</label>
                <textarea id="termBackContent${termInputCounter}" class="term-back-content"></textarea>
            `;
            termsInputContainer.appendChild(div);
            const deleteBtn = div.querySelector('.delete-term-btn');
            deleteBtn?.addEventListener('click', () => { div.remove(); renumberTermHeaders(); });
            // console.log(`–î–æ–±–∞–≤–ª–µ–Ω–æ –ø–æ–ª–µ –¥–ª—è —Ç–µ—Ä–º–∏–Ω–∞ ${termInputCounter}`);
        }

        function addProblemInputFields() {
            if (!problemsInputContainer) return;
            problemInputCounter++;
            const div = document.createElement('div');
            div.classList.add('problem-inputs');
            div.dataset.cardNumber = problemInputCounter;
             const deleteText = `${languages[currentLanguage]?.['delete-problem'] || '–£–¥–∞–ª–∏—Ç—å –ó–∞–¥–∞—á—É'} ${problemInputCounter}`;
            div.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <h4 class="problem-header">${languages[currentLanguage]?.['problem-header'] || '–ó–∞–¥–∞—á–∞'} ${problemInputCounter}</h4>
                    <button type="button" class="delete-problem-btn" aria-label="${deleteText}" title="${deleteText}">üóëÔ∏è</button>
                </div>
                <label for="problemTitle${problemInputCounter}" data-lang-key="problem-title-label">${languages[currentLanguage]?.['problem-title-label'] || '–ù–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:'}</label>
                <input type="text" id="problemTitle${problemInputCounter}" class="problem-title">
                <label for="problemContent${problemInputCounter}" data-lang-key="problem-content-label">${languages[currentLanguage]?.['problem-content-label'] || '–ó–∞–¥–∞—á–∞:'}</label>
                <textarea id="problemContent${problemInputCounter}" class="problem-content" required></textarea>
                <label for="problemAnswer${problemInputCounter}" data-lang-key="problem-answer-label">${languages[currentLanguage]?.['problem-answer-label'] || '–û—Ç–≤–µ—Ç (—á–∏—Å–ª–æ):'}</label>
                <input type="text" id="problemAnswer${problemInputCounter}" class="problem-answer" required placeholder="${languages[currentLanguage]?.['input-placeholder'] || '0'}">
            `;
            problemsInputContainer.appendChild(div);
            const deleteBtn = div.querySelector('.delete-problem-btn');
            deleteBtn?.addEventListener('click', () => { div.remove(); renumberProblemHeaders(); });
            // console.log(`–î–æ–±–∞–≤–ª–µ–Ω–æ –ø–æ–ª–µ –¥–ª—è –∑–∞–¥–∞—á–∏ ${problemInputCounter}`);
        }

        function toggleDeckTypeSections() {
            if (!deckTypeInput || !termsSection || !problemsSection) return;
            const selectedType = deckTypeInput.value;
            termsSection.style.display = (selectedType === 'terms' || selectedType === 'combined') ? 'block' : 'none';
            problemsSection.style.display = (selectedType === 'problems' || selectedType === 'combined') ? 'block' : 'none';
        }

        function createDeck(event) {
            event.preventDefault();
            if (!deckTitleInput || !deckTypeInput || !termsInputContainer || !problemsInputContainer) return;
            const deckTitle = deckTitleInput.value.trim();
            const deckDesc = deckDescInput?.value.trim() || '';
            const deckType = deckTypeInput.value;
            if (!deckTitle) {
                alert(languages[currentLanguage]?.['deck-title-required'] || '–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ª–æ–¥—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ.');
                return;
            }
            const collectedTermsCards = [];
            const collectedProblemsCards = [];
            if (deckType === 'terms' || deckType === 'combined') {
                termsInputContainer.querySelectorAll('.term-inputs').forEach((termDiv) => {
                    const frontTitle = termDiv.querySelector('.term-front-title')?.value.trim();
                    const frontContent = termDiv.querySelector('.term-front-content')?.value.trim();
                    const backFormula = termDiv.querySelector('.term-back-formula')?.value.trim();
                    const backUnits = termDiv.querySelector('.term-back-units')?.value.trim();
                    const backVars = termDiv.querySelector('.term-back-vars')?.value.trim();
                    const backContent = termDiv.querySelector('.term-back-content')?.value.trim();
                    if (frontContent) { // Require front content
                        collectedTermsCards.push({ front: { title: frontTitle || '', content: frontContent }, back: { formula: backFormula || '', units: backUnits || '', vars: backVars || '', content: backContent || '' } });
                    }
                });
            }
            if (deckType === 'problems' || deckType === 'combined') {
                problemsInputContainer.querySelectorAll('.problem-inputs').forEach((problemDiv) => {
                    const title = problemDiv.querySelector('.problem-title')?.value.trim();
                    const content = problemDiv.querySelector('.problem-content')?.value.trim();
                    const answer = problemDiv.querySelector('.problem-answer')?.value.trim();
                    if (content && answer) { // Require content and answer
                        collectedProblemsCards.push({ front: { title: title || '', content: content }, back: { content: answer } });
                    }
                });
            }
            if ((deckType === 'terms' && collectedTermsCards.length === 0) || (deckType === 'problems' && collectedProblemsCards.length === 0) || (deckType === 'combined' && collectedTermsCards.length === 0 && collectedProblemsCards.length === 0)) {
                alert(languages[currentLanguage]?.['add-one-card-alert'] || '–î–æ–±–∞–≤—å—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –≤–∞–ª–∏–¥–Ω—ã–π —Ç–µ—Ä–º–∏–Ω –∏–ª–∏ –∑–∞–¥–∞—á—É.');
                return;
            }
            const deckId = `custom-deck-${Date.now()}`;
            const newDeckData = { title: deckTitle, description: deckDesc, deckType: deckType };
            if (deckType === 'terms') newDeckData.cards = collectedTermsCards;
            else if (deckType === 'problems') newDeckData.cards = collectedProblemsCards;
            else { newDeckData.termsCards = collectedTermsCards; newDeckData.problemsCards = collectedProblemsCards; }
            customDecks[deckId] = newDeckData;
            saveCustomDecksToLocalStorage();
            combineAllDecks();
            populateDeckList();
            alert(`${languages[currentLanguage]?.['deck-created-success'] || '–ö–æ–ª–æ–¥–∞'} "${deckTitle}" ${languages[currentLanguage]?.['created-successfully'] || '—É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!'}`);
            if (createDeckModal) createDeckModal.style.display = 'none';
            loadDeck(deckId);
            createDeckForm.reset();
            termsInputContainer.innerHTML = ''; problemsInputContainer.innerHTML = '';
            termInputCounter = 0; problemInputCounter = 0;
            addTermInputFields(); addProblemInputFields();
            toggleDeckTypeSections();
        }


        // --- Event Listeners (Added achievements modal listener) ---
        document.addEventListener('DOMContentLoaded', () => {
            loadEarnedBadges(); // Load achievements on start
            initializeTheme();
            initializeLanguage();
            initializeDecks();

            // Modals
            chooseDeckBtn?.addEventListener('click', () => { if (deckModal) { populateDeckList(); deckModal.style.display = 'flex'; } });
            closeDeckModalBtn?.addEventListener('click', () => { if (deckModal) deckModal.style.display = 'none'; });
            createDeckBtn?.addEventListener('click', () => { if (createDeckModal) { /* ... reset form ... */ createDeckModal.style.display = 'flex'; } });
            closeCreateDeckModalBtn?.addEventListener('click', () => { if (createDeckModal) createDeckModal.style.display = 'none'; });
            // New Achievements Modal Listener
            achievementsBtn?.addEventListener('click', () => { if (achievementsModal) { populateAchievementsList(); achievementsModal.style.display = 'flex'; } });
            closeAchievementsModalBtn?.addEventListener('click', () => { if (achievementsModal) achievementsModal.style.display = 'none'; });

            // Close modals on background click
            window.addEventListener('click', (e) => {
                if (e.target === deckModal) deckModal.style.display = 'none';
                if (e.target === createDeckModal) createDeckModal.style.display = 'none';
                if (e.target === achievementsModal) achievementsModal.style.display = 'none'; // Close achievements modal
                if (languageMenu && languageToggle && !languageToggle.contains(e.target) && !languageMenu.contains(e.target)) languageMenu.style.display = 'none';
            });

            // Settings
            themeToggle?.addEventListener('click', toggleTheme);
            languageToggle?.addEventListener('click', (e) => {
                e.stopPropagation();
                if(languageMenu) languageMenu.style.display = languageMenu.style.display === 'block' ? 'none' : 'block';
            });
            languageMenu?.addEventListener('click', (e) => {
                const langOption = e.target.closest('.language-option');
                if (langOption) {
                    const lang = langOption.dataset.lang;
                    if (lang && languages[lang]) { updateLanguage(lang); languageMenu.style.display = 'none'; }
                }
            });

            // Card Controls
            prevBtn?.addEventListener('click', prevCard);
            nextBtn?.addEventListener('click', nextCard);
            flipBtn?.addEventListener('click', flipCard);
            shuffleBtn?.addEventListener('click', toggleShuffle);

            // Mode Selection
            modeCards.forEach(card => { card.addEventListener('click', () => { if (!card.classList.contains('disabled')) { const mode = card.dataset.mode; if(mode) switchMode(mode); } }); });

            // Problem Solving
            submitProblemAnswerBtn?.addEventListener('click', checkProblemAnswer);
            problemAnswerInput?.addEventListener('keypress', (e) => { if (e.key === 'Enter') checkProblemAnswer(); });
            problemAnswerInput?.addEventListener('input', hideAnswerFeedback);

            // Stats
            resetStatsBtn?.addEventListener('click', resetStats);

            // Deck Creation Form
            createDeckForm?.addEventListener('submit', createDeck);
            deckTypeInput?.addEventListener('change', toggleDeckTypeSections);
            addAnotherTermBtn?.addEventListener('click', addTermInputFields);
            addAnotherProblemBtn?.addEventListener('click', addProblemInputFields);

            console.log("–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ.");
        });
    </script>
</body>
</html>